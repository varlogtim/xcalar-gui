// module name must start with "UExt"
window.UExtDaxFns = (function(UExtDaxFns) {
    UExtDaxFns.buttons = [{
        "buttonText": "Install DAX UDF Package",
        "fnName": "install",
        "instruction": "Install DAX Functions as Xcalar UDF"
    }, {
        "buttonText": "Uninstall DAX UDF Package",
        "fnName": "uninstall",
        "instruction": "Uninstall DAX UDFs from Xcalar"
    }];

    UExtDaxFns.configParams = {
        notTableDependent: true
    };

    // UExtDaxFns.actionFn must reutrn a XcSDK.Extension obj or null
    UExtDaxFns.actionFn = function(functionName) {
        // it's a good convention to use switch/case to handle
        // different function in the extension and handle errors.
        switch (functionName) {
            case "install":
                return install();
            case "uninstall":
                return uninstall();
            default:
                return null;
        }
    };

    function install() {
        var ext = new XcSDK.Extension();
        // it's stringified from daxFns.ext.py
        var udf = "# PLEASE TAKE NOTE:\n\n# UDFs can only support\n# return values of\n# type String.\n\n# Function names that\n# start with __ are\n# considered private\n# functions and will not\n# be directly invokable.\n\n\n# DATETIME FUNCTIONS:\n# https://msdn.microsoft.com/en-us/library/ee634786.aspx\n\nfrom datetime import timedelta, datetime\nfrom dateutil.relativedelta import relativedelta\nfrom calendar import isleap as __isleap\nimport math\nfrom scipy.stats import beta, chi2, expon, poisson, norm\nfrom functools import reduce\n\n\ndefaultDateFmt = \"%m/%d/%Y\"\ndefaultTimeFmt = \"%H:%M:%S\"\n\n###\n#\n# Streaming UDF's for datetime\n#\n###\n\n#get generator for all dates between start and end included\n#start, end: must be of type Date\ndef __rangeOfDates(start, end):\n    for n in range(int((end - start).days) + 1):\n        yield start + timedelta(n)\n\n#return format to Xcalar design\ndef __toDate(date, columnName, inputFormat, index):\n    return {\n        columnName : date.strftime(inputFormat),\n        \"Row\" : index\n    }\n\n#use when startDate and endDate are explicit dates\n#generates a two column table with the following structure:\n#    <DateColumn>: all dates between startDate and endDate\n#    Row: contains numbers next to the dates in ascending order,\n#        used to sort the dates in Xcalar\ndef calenderExplicit(filePath, inStream, startDate = \"01/01/1996\",\n                      endDate = \"24/08/2005\", inputFormat = defaultDateFmt,\n                      columnName = \"Date\"):\n    start_date = datetime.strptime(startDate, inputFormat)\n    end_date = datetime.strptime(endDate, inputFormat)\n    for i, date in enumerate(__rangeOfDates(start_date, end_date)):\n        yield __toDate(date, columnName, inputFormat, i)\n\n#given the column number of the date column, returns the earliest\n#and latest dates in that column\ndef __get_dates(inStream, delimiter, dateColNo, inputFormat):\n    minDate = None\n    maxDate = None\n    for line in inStream:\n        date_str = line.split(delimiter)[dateColNo]\n        try:\n            curr_date = datetime.strptime(date_str, inputFormat)\n            if minDate == None or curr_date < minDate:\n                minDate = curr_date\n            if maxDate == None or curr_date > maxDate:\n                maxDate = curr_date\n        except:\n            continue\n    return (minDate, maxDate)\n\n#use when startDate or endDate are to be inferred from data\n#generates a two column table with the following structure:\n#    <DateColumn>: all dates between earliest date in column and\n#        last date in column, unless explicit start or end date\n#        specified in which case that is used.\n#    Row: contains numbers next to the dates in ascending order,\n#        used to sort the dates in Xcalar\ndef calendarMinmax(filePath, inStream, delimiter = '\\t',\n                    dateColNo = 0, inputFormat = defaultDateFmt,\n                    startDate = None, endDate = None,\n                    outputFormat = None, columnName = \"Date\"):\n    #keep same formating for output if none given\n    outputFormat = outputFormat or inputFormat\n    if startDate and endDate:\n        start_date = datetime.strptime(startDate, inputFormat)\n        end_date = datetime.strptime(endDate, inputFormat)\n    else:\n        dates = __get_dates(inStream, delimiter, dateColNo,\n                            inputFormat)\n        start_date = (datetime.strptime(startDate, inputFormat)\n                      if startDate else dates[0])\n        end_date = (datetime.strptime(endDate, inputFormat)\n                    if endDate else dates[1])\n    for i, date in enumerate(__rangeOfDates(start_date, end_date)):\n        yield __toDate(date, columnName, outputFormat, i + 1)\n\n###\n#\n# UDF's for datetime\n#\n###\n\n#convert dates to a default string format, so operations can run\n#without inputFormat being explicitly provided\ndef toDefaultDate(dateStr, inputFormat):\n    return datetime.strptime(dateStr, inputFormat).strftime(defaultDateFmt)\n\n#convert time to a default string format, so operations can run\n#without inputFormat being explicitly provided\ndef toDefaultTime(timeStr, inputFormat):\n    return datetime.strptime(timeStr, inputFormat).strftime(defaultTimeFmt)\n\n#def diff(startDate, endDate, intervalType = \"days\",\n#         inputFormat = defaultDateFmt):\n#    start_date = datetime.strptime(startDate, inputFormat)\n#    end_date = datetime.strptime(endDate, inputFormat)\n\n#returns day from [1,31]\ndef day(dateStr, inputFormat = defaultDateFmt):\n    return str(datetime.strptime(dateStr, inputFormat).day)\n\n#returns the same date m months later or before (caps at largest date\n#value in modified month)\ndef eDate(dateStr, m, inputFormat = defaultDateFmt):\n    return (datetime.strptime(dateStr, inputFormat) +\n            relativedelta(months = m)).strftime(inputFormat)\n\n#returns the last date m months later or before\ndef eoMonth(dateStr, m, inputFormat = defaultDateFmt):\n    #first we get the edate (see above) for m + 1\n    #replace the date value by 1 and then subtract 1 day\n    #this gives the last day of the month modified by m\n    return ((datetime.strptime(dateStr, inputFormat) +\n            relativedelta(months = m + 1)).replace(day = 1)\n            - timedelta(days = 1)).strftime(inputFormat)\n\n#returns hour from [0,23]\ndef hour(timeStr, inputFormat = defaultTimeFmt):\n    return str(datetime.strptime(timeStr, inputFormat).hour)\n\n#returns minute from [0, 59]\ndef minute(timeStr, inputFormat = defaultTimeFmt):\n    return str(datetime.strptime(timeStr, inputFormat).minute)\n\n#returns month from [1, 12]\ndef month(dateStr, inputFormat = defaultDateFmt):\n    return str(datetime.strptime(dateStr, inputFormat).month)\n\n#returns seconds from [0, 59]\ndef second(timeStr, inputFormat = defaultTimeFmt):\n    return str(datetime.strptime(timeStr, inputFormat).second)\n\n#returns weekday from [1, 7] with 1 being Monday\ndef weekday(dateStr, inputFormat = defaultDateFmt):\n    return str(datetime.strptime(dateStr, inputFormat).weekday() + 1)\n\n#returns week number form [1, 53] according to ISO 8601\ndef weekNum(dateStr, inputFormat = defaultDateFmt):\n    return datetime.strptime(dateStr, inputFormat).strftime(\"%V\")\n\n#return the year\ndef year(dateStr, inputFormat = defaultDateFmt):\n    return str(datetime.strptime(dateStr, inputFormat).year)\n\n#types for which we know the exact difference\ndeterministicTypes = [\"days\", \"hours\", \"minutes\", \"seconds\"]\n#returns the difference in date/time for two dates in the format specified\n#acceptable: days, hours, minutes, seconds, years, months, quarters\ndef dateDiff(endDate, startDate, intervalType = \"days\",\n              inputFormat = defaultDateFmt):\n    start_date = datetime.strptime(startDate, inputFormat)\n    end_date = datetime.strptime(endDate, inputFormat)\n\n    #logging.debug(str(start_date))\n    try:\n        #currently returns integers, this can be modified by removing cast to\n        #int for the deterministic types\n        if intervalType in deterministicTypes:\n            diff_tdelta = end_date - start_date\n            if intervalType == \"days\": return str(diff_tdelta.days)\n            total_seconds = diff_tdelta.total_seconds()\n            if intervalType == \"seconds\": return str(int(total_seconds))\n            elif intervalType == \"minutes\": return str(int(total_seconds/60))\n            elif intervalType == \"hours\": return str(int(total_seconds/3600))\n        else:\n            year_diff = end_date.year - start_date.year\n            if intervalType == \"years\": return str(year_diff)\n            month_diff = 12*year_diff + end_date.month - start_date.month\n            if intervalType == \"months\": return str(month_diff)\n            #get quarter for both months and subtract the two. Cannot change\n            #order of division and subtraction.\n            quarter_diff = (4*year_diff + (end_date.month - 1)/3 -\n                            (start_date.month - 1)/3)\n            if intervalType == \"quarters\": return str(quarter_diff)\n    except:\n        pass\n\n#return the fraction of the year represented by the difference of two dates,\n#with the modified day\ndef __calc360dayDiff(edate, sdate, eday, sday):\n    duration = ((edate.year - sdate.year)*360 +\n                (edate.month - sdate.month)*30 +\n                (eday - sday))\n    return float(duration)/360\n\ndef __yf_usNasd(edate, sdate):\n    #keep day the same if no condition for modification is true\n    eday, sday = edate.day, sdate.day\n    #if sdate is on last day of feb or is equal to 31\n    if (((sdate + timedelta(1)).month == (sdate.month + 1))\n        and sdate.day != 30):\n        sday = 30\n        #edate is only modified if sdate is modified and it\n        #falls on the last day of the month\n        if (edate + timedelta(1)).month == (edate.month + 1):\n            #eday changes if sday and eday are on the last\n            #day of feb or sday and eday are both 31\n            if (edate.month == 2) == (sdate.month == 2):\n                eday = 30\n    return __calc360dayDiff(edate, sdate, eday, sday)\n\ndef __yf_actual(edate, sdate):\n    return float((edate - sdate).days)/(365 + __isleap(sdate.year))\n\ndef __yf_actual360(edate, sdate):\n    return float((edate - sdate).days)/360\n\ndef __yf_actual365(edate, sdate):\n    return float((edate - sdate).days)/365\n\ndef __yf_eu360(edate, sdate):\n    eday, sday = min(edate.day, 30), min(sdate.day, 30)\n    return __calc360dayDiff(edate, sdate, eday, sday)\n\nyf_fnMap = [__yf_usNasd, __yf_actual, __yf_actual360, __yf_actual365, __yf_eu360]\n#Return the fraction of an year represented by the difference between start\n#and end dates with the specified format given in the arg\ndef yearFrac(endDate, startDate, basis = 0, inputFormat = defaultDateFmt):\n    start_date = datetime.strptime(startDate, inputFormat)\n    end_date = datetime.strptime(endDate, inputFormat)\n    #pass computation to specific function based on inputFormat\n    #(Python's equivalent of a simple switch - case)\n    return str(yf_fnMap[basis](end_date, start_date))\n\n\n# INFORMATION FUNCTIONS\n# https://msdn.microsoft.com/en-us/library/ee634552.aspx\n\ndef isBlank(val):\n    return val == \"\"\n\ndef isError(val):\n    return val == None\n\ndef isEven(n):\n    n = int(n)\n    return (n % 2) == 0\n\ndef isLogical(val):\n    return type(val) == bool\n\ndef isNumber(n):\n    try:\n        n = float(n)\n        return True\n    except:\n        return False\n\ndef isOdd(n):\n    n = int(n)\n    return (n % 2) == 1\n\n\n# LOGICAL FUNCTIONS:\n# https://msdn.microsoft.com/en-us/library/ee634365.aspx\n\n\n#if there is an error in the conditional, returns outVal\ndef ifError(cond, ifTrue, ifFalse):\n    #FNF, Xcalar's error message for cols is passed\n    #as None to python.\n    if (cond == None): return str(ifTrue)\n    else: return ifFalse\n\n#match is the column\n#subsequent args must be of the form \"case,result\"\ndef switch(match, *case_res_pairs):\n    for pair in args[1:]:\n        (case, res) = tuple(pair.split(','))\n        if (str(match) == case):\n            return res\n\n\n# MATH AND TRIG FUNCTIONS:\n# https://msdn.microsoft.com/en-us/library/ee634241.aspx\n\n#permutation - nPr\ndef permut(n, r):\n    n = int(n)\n    r = int(r)\n    #eliminates the multiplication required for (n-r)! as the same term is\n    #divided\n    return str(reduce(int.__mul__, list(range(n - r + 1, n + 1)), 1))\n\n#direct combination - nCr\ndef combin(n, r):\n    n = int(n)\n    r = int(r)\n    r = min(r, n - r) # to get least number of multiplications in reduce\n    #eliminates the need to calculate 3 factorials by removing common terms\n    #in n! and (n - r)!\n    return str(reduce(int.__mul__, list(range(n - r + 1, n + 1)), 1) / math.factorial(r))\n\n#mathematical definition of combination to check result\n# def comb_checker(n_, r_):\n#    n = int(n_)\n#    r = int(r_)\n#    return str(math.factorial(n) / (math.factorial(r) * math.factorial(n - r)))\n\n#combination with repetition - (n + r - 1)C(n - 1)\ndef combinA(n, r):\n    n = int(n)\n    r = int(r)\n    new_n = n + r - 1\n    new_r = n - 1\n    #since mathematical formula of combA(n, r) is (n + r - 1)C(n - 1)\n    return comb(new_n, new_r)\n\n#mathematical definition of combination with repetition to check result\n#def combA_checker(n_, r_):\n#    n = int(n_)\n#    r = int(r_)\n#    return str(math.factorial(n + r - 1) / (math.factorial(r) * math.factorial(n - 1)))\n\n#round to nearest even number\n#to round up, replace round with math.ceil\ndef __even(x):\n    return int(round(float(x)/2)*2)\n\ndef even(x):\n    return str(__even(x))\n\n#factorial\ndef fact(n):\n    return str(math.factorial(int(n)))\n\n#__gcd implementation is the same as that in fractions module\n#could also do from fractions import gcd\ndef __gcd(a, b):\n    a, b = int(a), int(b)\n    while b:\n        a, b = b, a % b\n    return a\n\n#GCD of list of numbers\ndef gcd(*numbers):\n    return str(reduce(__gcd, numbers, 0))\n\n#LCM of a and b\ndef __lcm(a, b):\n    a, b = int(a), int(b)\n    #gcd(a, b) * lcm(a, b) = a * b\n    return (a * b) / __gcd(a, b)\n\n#LCM of list of numbers\ndef lcm(*numbers):\n    return str(reduce(__lcm, numbers, 1))\n\n#round to nearest odd number\n#to round up, replace round with math.ceil\ndef odd(x):\n    return str(__even(x + 1) - 1)\n\n#Returns -1, 0, or 1 if a < 0, a == 0 or a > 0 respectively\ndef sign(x):\n    x = int(x)\n    #using True = 1 and False = 0, the following expression returns the desired\n    #result\n    return str((x > 0) - (x < 0))\n\n\n# STATISTICAL FUNCTIONS:\n# https://msdn.microsoft.com/en-us/library/ee634822.aspx\n\n# refer to scipy.stats (link below) to get many more built-in stats functions\n# https://docs.scipy.org/doc/scipy-0.19.0/reference/stats.html\n\n#probability functions follow scipy format rather than DAX so more wrappers\n#with same format can be created with ease\n\n# Below are Xcalar wrappers for particular functions of some distributions\n\n# beta distribution wrappers\n# https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.stats.beta.html#scipy.stats.beta\n\ndef betaPdf(x, a, b, loc = 0, scale = 1):\n    return str(beta.pdf(x, a, b, loc, scale))\n\ndef betaCdf(x, a, b, loc = 0, scale = 1):\n    return str(beta.cdf(x, a, b, loc, scale))\n\ndef betaPpf(p, a, b, loc = 0, scale = 1):\n    return str(beta.ppf(p, a, b, loc, scale))\n\n# chi-squared distribution wrappers\n# https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.stats.chi2.html#scipy.stats.chi2\n\ndef chisqPdf(x, degOfFreedom, loc = 0, scale = 1):\n    return str(chi2.pdf(x, degOfFreedom, loc, scale))\n\ndef chisqCdf(x, degOfFreedom, loc = 0, scale = 1):\n    return str(chi2.cdf(x, degOfFreedom, loc, scale))\n\ndef chisqPpf(p, degOfFreedom, loc = 0, scale = 1):\n    return str(chi2.ppf(p, degOfFreedom, loc, scale))\n\n# exponential distribution wrappers\n# modified to include the paramater lambda for rate\n# https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.stats.expon.html#scipy.stats.expon\n\ndef exponPdf(x, _lambda, loc = 0, scale = 1):\n    return str(_lambda*expon.pdf(_lambda*x, loc, scale))\n\ndef exponCdf(x, _lambda, loc = 0, scale = 1):\n    return str(expon.cdf(_lambda*x, loc, scale))\n\ndef exponPpf(p, _lambda, loc = 0, scale = 1):\n    return str(expon.ppf(p, loc, scale)/_lambda)\n\n# Poisson distribution wrappers\n# https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.stats.poisson.html#scipy.stats.poisson\n\ndef poissonPdf(k, mu, loc = 0):\n    return str(poisson.pmf(k, mu, loc))\n\ndef poissonCdf(k, mu, loc = 0):\n    return str(poisson.cdf(k, mu, loc))\n\ndef poissonPpf(p, mu, loc = 0):\n    return str(poisson.ppf(p, mu, loc))\n\n\ndef confidenceNorm(confidence_level, mean, std, size):\n    return str(mean - norm.interval(confidence_level, loc = mean,\n                                    scale = std/(size**0.5))[0])\n\ndef confidenceT(confidence_level, mean, std, size):\n    return str(norm.interval(confidence_level, loc = mean,\n                             scale = std/(size**0.5)))\n\n\n# TEXT FUNCTIONS:\n# https://msdn.microsoft.com/en-us/library/ee634938.aspx\n\n#ascii val of first character in the text\ndef code(text):\n    return str(ord(text[0]))\n\ndef lower(text):\n    return text.lower()\n\n#replaces part of a text string, based on the number of character\n#range you specify, with a different text string.\ndef replace(text, swapStr, startIndex, endIndex):\n    return text[:startIndex] + swapStr + text[endIndex:]\n\n#concatenates text to itself n times\ndef rept(text, n):\n    return text * n\n\ndef upper(text):\n    return text.upper()";
        var moduleName = "dax";
        ext.start = function() {
            return XcalarUploadPython(moduleName, udf)
        };

        return ext;
    }

    function uninstall() {
        var ext = new XcSDK.Extension();
        var moduleName = "dax";
        ext.start = function() {
            return XcalarDeletePython(moduleName);
        };

        return ext;
    }

    return UExtDaxFns;
}({}));


