window.DF = (function($, DF) {
    var dataflows = {};

    DF.restore = function(retMeta) {
        var deferred = jQuery.Deferred();
        XcalarListRetinas()
        .then(function(list) {
            var promise;
            for (var i = 0; i < list.numRetinas; i++) {
                var retName = list.retinaDescs[i].retinaName;
                if (retName.indexOf("#") > -1) {
                    // These are retinas that are generated by retina replay
                    // Do not show them
                    // We do not allow uploading or creation of retinas with #
                    continue;
                }

                if (retName in retMeta) {
                    dataflows[retName] = retMeta[retName];
                } else {
                    console.warn("No meta for dataflow", retName);
                    dataflows[retName] = new Dataflow(retName);
                }
            }

            DFCard.refreshDFList(true, true);
            if (list.numRetinas > 0) {
                var firstDFName = $("#dfgMenu").find(".groupName").eq(0).text();
                promise = DF.updateDF(firstDFName);
            } else {
                promise = PromiseHelper.resolve();
            }

            promise
            .then(deferred.resolve)
            .fail(deferred.reject);
        })
        .fail(deferred.reject);

        return deferred.promise();
    };

    DF.refresh = function(retMeta) {
        // This call now has to return a promise
        var deferred = jQuery.Deferred();
        var retArray = [];

        XcalarListRetinas()
        .then(function(list) {
            for (var i = 0; i < list.numRetinas; i++) {
                var retName = list.retinaDescs[i].retinaName;
                if (retName.indexOf("#") > -1) {
                    // These are retinas that are generated by retina replay
                    // Do not show them
                    // We do not allow uploading or creation of retinas with #
                    continue;
                }
                retArray.push(XcalarGetRetina(retName));
            }

            return PromiseHelper.when.apply({}, retArray);
        })
        .then(function() {
            dataflows = {}; // Reset dataflow cache
            var retStructs = arguments;

            for (var i = 0; i < retStructs.length; i++) {
                if (retStructs[i] == null) {
                    continue;
                }
                // Populate node information
                var retName = retStructs[i].retina.retinaDesc.retinaName;
                if (retName in retMeta) {
                    dataflows[retName] = retMeta[retName];
                } else {
                    console.warn("No meta for dataflow", retName);
                    dataflows[retName] = new Dataflow(retName);
                }

                updateDFInfo(retStructs[i]);

                // Populate export column information
                addColumns(retName);
            }


            DFCard.refreshDFList(true);

            deferred.resolve();
        })
        .fail(deferred.reject);

        return deferred.promise();
    };

    DF.getAllDataflows = function() {
        return (dataflows);
    };

    DF.getNumDataflows = function() {
        return (Object.keys(dataflows).length);
    };

    DF.getAllCommitKeys = function() {
        // Only commit stuff that we cannot recreate
        var deepCopy = xcHelper.deepCopy(dataflows);
        for (var df in deepCopy) {
            delete deepCopy[df].nodeIds;
            delete deepCopy[df].retinaNodes;
            delete deepCopy[df].columns;
        }
        return deepCopy;
    };

    DF.getDataflow = function(dataflowName) {
        return (dataflows[dataflowName]);
    };

    DF.addDataflow = function(dataflowName, dataflow, expTableName, options) {
        var isUpload = false;
        if (options) {
            isUpload = options.isUpload;
        }
        var deferred = jQuery.Deferred();
        dataflows[dataflowName] = dataflow;

        var innerDef;
        if (isUpload) {
            innerDef = PromiseHelper.resolve();
        } else {
            innerDef = createRetina(dataflowName, expTableName);
        }

        innerDef
        .then(function() {
            return (XcalarGetRetina(dataflowName));
        })
        .then(function(retInfo) {
            updateDFInfo(retInfo);
            if (isUpload) {
                addColumns(dataflowName, retInfo);
            }
            // XXX TODO add sql
            DFCard.addDFToList(dataflowName);
            KVStore.commit();
            deferred.resolve();
        })
        .fail(function(error) {
            delete dataflows[dataflowName];
            deferred.reject(error);
        });

        return (deferred.promise());
    };

    DF.removeDataflow = function(dataflowName) {
        var deferred = jQuery.Deferred();
        var hasRemoveSched = false;

        DF.removeScheduleFromDataflow(dataflowName)
        .then(function() {
            hasRemoveSched = true;
            return XcalarDeleteRetina(dataflowName);
        })
        .then(function() {
            resolveDelete();
            deferred.resolve();
        })
        .fail(function(error) {
            if (typeof error === "object" &&
                error.status === StatusT.StatusRetinaNotFound)
            {
                resolveDelete();
                deferred.resolve();
            } else {
                if (hasRemoveSched) {
                    KVStore.commit();
                }
                deferred.reject(error);
            }
        });

        return deferred.promise();

        function resolveDelete() {
            delete dataflows[dataflowName];
            KVStore.commit();
        }
    };

    // For addining. modifying and removing the schedule
    DF.getSchedule = function(dataflowName) {
        var dataflow = dataflows[dataflowName];
        if (dataflow) {
            return dataflow.schedule;
        }
    };

    DF.addScheduleToDataflow = function(dataflowName, allOptions) {
        var dataflow = dataflows[dataflowName];
        if (dataflow) {
            if (!dataflow.schedule) {
                dataflow.schedule = new SchedObj(allOptions);
                var substitutions = getSubstitutions(dataflowName);
                var options = getOptions(allOptions);
                var timingInfo = getTimingInfo(allOptions);
                XcalarCreateSched(dataflowName, dataflowName,
                    substitutions, options, timingInfo)
                .then(function() {
                    KVStore.commit();
                });
            } else {
                var schedule = dataflow.schedule;
                schedule.update(allOptions);
                XcalarDeleteSched(dataflowName)
                .then(function() {
                    var substitutions = getSubstitutions(dataflowName);
                    var options = getOptions(allOptions);
                    var timingInfo = getTimingInfo(allOptions);
                    XcalarCreateSched(dataflowName, dataflowName,
                        substitutions, options, timingInfo)
                    .then(function() {
                        KVStore.commit();
                    });
                });
            }
        } else {
            console.warn("No such dataflow exist!");
        }
    };

    DF.removeScheduleFromDataflow = function(dataflowName) {
        var dataflow = dataflows[dataflowName];
        if (!dataflow) {
            var error = xcHelper.replaceMsg(DFTStr.NoTExists, {
                "df": dataflowName
            });
            return PromiseHelper.reject(error);
        }

        var deferred = jQuery.Deferred();
        XcalarDeleteSched(dataflowName)
        .then(function() {
            dataflow.schedule = null;
            deferred.resolve();
        })
        .fail(deferred.reject);

        return deferred.promise();
    };

    DF.hasSchedule = function(dataflowName) {
        var dataflow = dataflows[dataflowName];
        if (dataflow) {
            return dataflow.hasSchedule();
        } else {
            console.warn("No such dataflow exist!");
            return false;
        }
    };

    DF.hasDataflow = function(dataflowName) {
        return dataflows.hasOwnProperty(dataflowName);
    };

    DF.updateDF = function(dfName) {
        var deferred = jQuery.Deferred();

        XcalarGetRetina(dfName)
        .then(function(retStruct) {
            updateDFInfo(retStruct);
            addColumns(dfName);
            deferred.resolve();
        })
        .fail(deferred.reject);

        return deferred.promise();
    };

    function createRetina(retName, tableName) {
        var df = dataflows[retName];
        var columns = [];

        var tableArray = [];

        df.columns.forEach(function(colInfo) {
            var col = new ExColumnNameT();
            col.name = colInfo.backCol; // Back col name
            col.headerAlias = colInfo.frontCol; // Front col name
            columns.push(col);
        });

        var retinaDstTable = new XcalarApiRetinaDstT();
        retinaDstTable.numColumns = columns.length;
        retinaDstTable.target = new XcalarApiNamedInputT();
        retinaDstTable.target.isTable = true;
        retinaDstTable.target.name = tableName;
        retinaDstTable.columns = columns;
        tableArray.push(retinaDstTable);
        return XcalarMakeRetina(retName, tableArray);
    }

    // called after retina is created to update the ids of dag nodes
    function updateDFInfo(retInfo) {
        var retina = retInfo.retina;
        var retName = retina.retinaDesc.retinaName;
        var dataflow = dataflows[retName];
        var nodes = retina.retinaDag.node;

        dataflow.retinaNodes = nodes;

        for (var i = 0; i < retina.retinaDag.numNodes; i++) {
            var tableName = nodes[i].name.name;
            dataflow.nodeIds[tableName] = nodes[i].dagNodeId;
        }
    }

    function addColumns(dataflowName) {
        var dFlow = DF.getDataflow(dataflowName);
        for (i = 0; i < dFlow.retinaNodes.length; i++) {
            if (dFlow.retinaNodes[i].api === XcalarApisT.XcalarApiExport) {
                var exportCols = dFlow.retinaNodes[i].input.exportInput
                                                           .meta.columns;
                for (var j = 0; j < exportCols.length; j++) {
                    var newCol = {};
                    newCol.frontCol = exportCols[j].headerAlias;
                    newCol.backCol = exportCols[j].name;
                    dFlow.columns.push(newCol);
                }
                break;
            }
        }
    }

    function getSubstitutions(dataflowName) {
        var paramsArray = [];
        var dfObj = DF.getDataflow(dataflowName);
        var parameters = dfObj.paramMap;
        for (var param in parameters) {
            var p = new XcalarApiParameterT();
            p.parameterName = param;
            p.parameterValue = parameters[param];
            paramsArray.push(p);
        }
        return paramsArray;
    }

    function getOptions(allOptions) {
        var options = {
            "activeSession": allOptions.activeSession,
            "newTableName": allOptions.newTableName,
            "usePremadeCronString": allOptions.usePremadeCronString,
            "premadeCronString": allOptions.premadeCronString
        };
        return options;
    }
    function getTimingInfo(allOptions) {
        var timingInfo = {
            "startTime": allOptions.startTime,
            "dateText": allOptions.dataText,
            "timeText": allOptions.timeText,
            "repeat": allOptions.repeat,
            "modified": allOptions.modified
        };
        return timingInfo;
    }

    return (DF);

}(jQuery, {}));
