class DagNodeSet extends DagNode {
    protected input: DagNodeSetInput;

    public constructor(options: DagNodeInfo) {
        super(options);
        this.type = DagNodeType.Set;
        this.maxParents = -1;
        this.minParents = 1;
    }

    /**
     * @returns {DagNodeSetInput} Set(union/except/intersect) node parameters
     */
    public getParam(): DagNodeSetInput {
        let columns = this.input.columns;
        if (columns == null) {
            columns = this.getParents().map(() => {
                return [{
                    sourceColumn: "",
                    destColumn: "",
                    columnType: ColumnType.string,
                    cast: false
                }]
            });
        }
        return {
            unionType: this.input.unionType || UnionType.Union,
            columns: this.input.columns || columns,
            dedup: this.input.dedup || false
        };
    }

    /**
     * Set set(union/except/intersect) node's parameters
     * @param input {DagNodeSetInput}
     * @param input.unionType {string} Join't type
     * @param input.columns tables' column infos
     * @param input.dedup {boolean} Remove deduplicate rows or not
     */
    public setParam(input: DagNodeSetInput = <DagNodeSetInput>{}) {
        this.input = {
            unionType: input.unionType,
            columns: input.columns,
            dedup: input.dedup
        }
        super.setParam();
    }

    public lineageChange(_columns: ProgCol[]): DagLineageChange {
        const changes: {from: ProgCol, to: ProgCol}[] = [];
        let finalCols: ProgCol[] = [];
        if (this.input.columns && this.input.columns.length > 0) {
            finalCols = this.input.columns[0].map((colInfo) => {
                const colName: string = colInfo.destColumn;
                const colType: ColumnType = colInfo.columnType;
                if (xcHelper.parsePrefixColName(colName).prefix) {
                    throw new Error("column generated by set operation cannot have prefix");
                }
                return ColManager.newPullCol(colName, colName, colType);
            });

            const parents: DagNode[] = this.getParents();
            this.input.columns.forEach((colLists, i) => {
                const colMap: Map<string, ProgCol> = new Map();
                parents[i].getLineage().getColumns().forEach((prgoCol) => {
                    colMap.set(prgoCol.getBackColName(), prgoCol);
                });
                colLists.forEach((colInfo, j) => {
                    const colName: string = colInfo.sourceColumn;
                    const oldProgCol: ProgCol = colMap.get(colName);
                    changes.push({
                        from: oldProgCol,
                        to: finalCols[j]
                    });
                    colMap.delete(colName);
                });

                for (let prgoCol of colMap.values()) {
                    changes.push({
                        from: prgoCol,
                        to: null
                    });
                }
            });
        }

        return {
            columns: finalCols,
            changes: changes
        };
    }
}