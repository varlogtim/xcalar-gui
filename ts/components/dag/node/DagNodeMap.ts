class DagNodeMap extends DagNode {
    protected input: DagNodeMapInput;
    private _aggregates: string[];

    public constructor(options: DagNodeMapInfo) {
        super(options);
        this.type = DagNodeType.Map;
        this.allowAggNode = true;
        this.minParents = 1;
        this._aggregates = options.aggregates || [];
        this.display.icon = "&#xe9da;";
        const namedAggs = Aggregates.getNamedAggs();
        const self = this;
        let errorAggs = [];
        this._aggregates.forEach((aggregateName: string) => {
            if (!namedAggs[aggregateName.substring(1)]) {
                errorAggs.push(aggregateName);
            }
        });
        if (errorAggs.length) {
            self.beErrorState(StatusMessageTStr.AggregateNotExist + errorAggs);
        }
    }

    /**
     * @returns {string[]} used aggregates
     */
    public getAggregates(): string[] {
        return this._aggregates;
    }

    /**
     * Sets the aggregates for this node
     * @param aggregates
     */
    public setAggregates(aggregates: string[]): void {
        this._aggregates = aggregates;
        super.setAggregates(aggregates);
    }

    /**
     * @returns {DagNodeMapInput} Map node parameters
     */
    public getParam(): DagNodeMapInput {
        return {
            eval: this.input.eval || [{evalString: "", newField: ""}],
            icv: this.input.icv || false,
        };
    }

    /**
     * Set map node's parameters
     * @param input {DagNodeMapInput}
     * @param input.eval {Array} array of {evalString, newFieldName}
     */
    public setParam(input: DagNodeMapInput = <DagNodeMapInput>{}) {
        this.input = {
            eval: input.eval,
            icv: input.icv,
        }
        super.setParam();
    }

    public lineageChange(columns: ProgCol[]): DagLineageChange {
        const changes: {from: ProgCol, to: ProgCol}[] = [];

        this.input.eval.forEach((evalInput) => {
            const colName: string = evalInput.newField;
            if (xcHelper.parsePrefixColName(colName).prefix) {
                throw new Error("columns generated by map cannot have prefix");
            }

            const func = XDParser.XEvalParser.parseEvalStr(evalInput.evalString);
            const colType: ColumnType = this._getOpType(func);
            const progCol = ColManager.newPullCol(colName, colName, colType);
            let fromCol = null;
            if (this.subType === DagNodeSubType.Cast) {
                const fromColName = (<ParsedEvalArg>func.args[0]).value;
                for (let i = 0; i < columns.length; i++) {
                    if (columns[i].getBackColName() === fromColName) {
                        fromCol = columns.splice(i, 1)[0];
                        break;
                    }
                }
            }
            columns.push(progCol);
            changes.push({
                from: fromCol,
                to: progCol
            });
        });


        return {
            columns: columns,
            changes: changes
        };
    }

    public applyColumnMapping(renameMap): void {
        try {
            this.input.eval.forEach(evalObj => {
                evalObj.evalString = this._replaceColumnInEvalStr(evalObj.evalString, renameMap.columns);
            });
        } catch(err) {
            console.error(err);
        }
        super.setParam();
    }

    /**
     * Get the used UDF modules in the node
     */
    public getUsedUDFModules(): Set<string> {
        const set: Set<string> = new Set();
        this.getParam().eval.forEach((evalArg) => {
            try {
                const arg = XDParser.XEvalParser.parseEvalStr(evalArg.evalString);
                this._getUDFFromArg(arg, set);
            } catch (e) {
                console.error(e);
            }
        });
        return set;
    }

    private _getOpType(func: ParsedEval): ColumnType {
        const operator: string = func.fnName;
        let colType: ColumnType = null;
        const opsMap = XDFManager.Instance.getOperatorsMap();
        for (let category in opsMap) {
            const ops = opsMap[category];
            const opInfo = ops[operator];
            if (opInfo) {
                colType = xcHelper.getDFFieldTypeToString(opInfo.outputType);
                break;
            }
        }
        return colType;
    }

    protected _getSerializeInfo(): DagNodeMapInfo {
        let info = super._getSerializeInfo();
        info['aggregates'] = this._aggregates;
        return info;
    }

    private _getUDFFromArg(arg: object, set: Set<string> ): void {
        const fnName: string = arg["fnName"];
        if (fnName == null) {
            return;
        }
        const splits: string[] = fnName.split(":");
        if (splits.length === 1) {
            return;
        }
        const moduleName: string = splits[0];
        set.add(moduleName);
        // recusrive check the arg
        if (arg["args"] != null) {
            arg["args"].forEach((subArg) => {
                this._getUDFFromArg(subArg, set);
            });
        }
    }
}