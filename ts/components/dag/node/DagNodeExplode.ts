class DagNodeExplode extends DagNode {
    protected input: DagNodeExplodeInput;

    public constructor(options: DagNodeInfo) {
        super(options);
        this.type = DagNodeType.Explode;
        this.minParents = 1;
        this.maxParents = 1;
        this.display.icon = '&#xe9d7;';
        this.input = new DagNodeExplodeInput(<DagNodeExplodeInputStruct>options.input);
    }

    public static readonly specificSchema = {
        "definitions": {},
        "$schema": "http://json-schema.org/draft-07/schema#",
        "$id": "http://example.com/root.json",
        "type": "object",
        "additionalProperties": true,
        "required": [
          "parents"
        ],
        "properties": {
          "parents": {
            "$id": "#/properties/parents",
            "type": "array",
            "maxItems": 1,
            "items": {
              "$id": "#/properties/parents/items",
              "type": "string",
              "pattern": "^(.*)$"
            }
          }
        }
    };

    public setParam(param: DagNodeExplodeInputStruct): void {
        this.input.setInput({
            sourceColumn: param.sourceColumn,
            delimiter: param.delimiter,
            destColumn: param.destColumn
        });
        super.setParam();
    }

    public lineageChange(
        columns: ProgCol[],
        replaceParameters?: boolean
    ): DagLineageChange {
        const newColName = this.input.getInput(replaceParameters).destColumn;
        const changes = [];
        const allCols = columns.map((v) => v);
        if (newColName.length > 0) {
            const newCol = ColManager.newPullCol(newColName, newColName, ColumnType.string);
            if (xcHelper.parsePrefixColName(newColName).prefix) {
                throw new Error("columns generated by map cannot have prefix");
            }
            changes.push({from: null, to: newCol});
            allCols.push(newCol);
        }

        return {
            columns: allCols,
            changes: changes
        };
    }

    /**
     * @override
     */
    protected _genParamHint(): string {
        let hint: string = "";
        const input: DagNodeExplodeInputStruct = this.getParam();
        if (input.sourceColumn && input.delimiter) {
            hint = `Explode ${input.sourceColumn} by ${input.delimiter}`;
        }
        return hint;
    }

    protected _getColumnsUsedInInput(): Set<string> {
        const set = new Set();
        set.add(this.input.getInput().sourceColumn);
        return set;
    }
}