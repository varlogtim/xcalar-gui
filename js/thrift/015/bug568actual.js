#!/usr/bin/phantomjs --web-security=false
//
// *********************************************
// *** DO NOT EDIT!  This file was autogenerated
// by Makefile.am. Please edit MgmtTest.js instead
// *********************************************
//
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var Thrift = {
    Version: '0.9.1',
/*
    Description: 'JavaScript bindings for the Apache Thrift RPC system',
    License: 'http://www.apache.org/licenses/LICENSE-2.0',
    Homepage: 'http://thrift.apache.org',
    BugReports: 'https://issues.apache.org/jira/browse/THRIFT',
    Maintainer: 'dev@thrift.apache.org',
*/

    Type: {
        'STOP' : 0,
        'VOID' : 1,
        'BOOL' : 2,
        'BYTE' : 3,
        'I08' : 3,
        'DOUBLE' : 4,
        'I16' : 6,
        'I32' : 8,
        'I64' : 10,
        'STRING' : 11,
        'UTF7' : 11,
        'STRUCT' : 12,
        'MAP' : 13,
        'SET' : 14,
        'LIST' : 15,
        'UTF8' : 16,
        'UTF16' : 17
    },

    MessageType: {
        'CALL' : 1,
        'REPLY' : 2,
        'EXCEPTION' : 3
    },

    objectLength: function(obj) {
        var length = 0;
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                length++;
            }
        }

        return length;
    },

    inherits: function(constructor, superConstructor) {
      //Prototypal Inheritance http://javascript.crockford.com/prototypal.html
      function F() {}
      F.prototype = superConstructor.prototype;
      constructor.prototype = new F();
    }
};



Thrift.TException = function(message) {
    this.message = message;
};
Thrift.inherits(Thrift.TException, Error);
Thrift.TException.prototype.name = 'TException';

Thrift.TApplicationExceptionType = {
    'UNKNOWN' : 0,
    'UNKNOWN_METHOD' : 1,
    'INVALID_MESSAGE_TYPE' : 2,
    'WRONG_METHOD_NAME' : 3,
    'BAD_SEQUENCE_ID' : 4,
    'MISSING_RESULT' : 5,
    'INTERNAL_ERROR' : 6,
    'PROTOCOL_ERROR' : 7,
    'INVALID_TRANSFORM' : 8,
    'INVALID_PROTOCOL' : 9,
    'UNSUPPORTED_CLIENT_TYPE' : 10
};

Thrift.TApplicationException = function(message, code) {
    this.message = message;
    this.code = (code === null) ? 0 : code;
};
Thrift.inherits(Thrift.TApplicationException, Thrift.TException);
Thrift.TApplicationException.prototype.name = 'TApplicationException';

Thrift.TApplicationException.prototype.read = function(input) {
    while (1) {
        var ret = input.readFieldBegin();

        if (ret.ftype == Thrift.Type.STOP) {
            break;
        }

        var fid = ret.fid;

        switch (fid) {
            case 1:
                if (ret.ftype == Thrift.Type.STRING) {
                    ret = input.readString();
                    this.message = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
            case 2:
                if (ret.ftype == Thrift.Type.I32) {
                    ret = input.readI32();
                    this.code = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
           default:
                ret = input.skip(ret.ftype);
                break;
        }

        input.readFieldEnd();
    }

    input.readStructEnd();
};

Thrift.TApplicationException.prototype.write = function(output) {
    var xfer = 0;

    output.writeStructBegin('TApplicationException');

    if (this.message) {
        output.writeFieldBegin('message', Thrift.Type.STRING, 1);
        output.writeString(this.getMessage());
        output.writeFieldEnd();
    }

    if (this.code) {
        output.writeFieldBegin('type', Thrift.Type.I32, 2);
        output.writeI32(this.code);
        output.writeFieldEnd();
    }

    output.writeFieldStop();
    output.writeStructEnd();
};

Thrift.TApplicationException.prototype.getCode = function() {
    return this.code;
};

Thrift.TApplicationException.prototype.getMessage = function() {
    return this.message;
};

/**
 *If you do not specify a url then you must handle ajax on your own.
 *This is how to use js bindings in a async fashion.
 */
Thrift.Transport = function(url) {
    this.url = url;
    this.wpos = 0;
    this.rpos = 0;

    this.send_buf = '';
    this.recv_buf = '';
};

Thrift.Transport.prototype = {

    //Gets the browser specific XmlHttpRequest Object
    getXmlHttpRequestObject: function() {
        try { return new XMLHttpRequest(); } catch (e1) { }
        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

        throw "Your browser doesn't support the XmlHttpRequest object.";
    },

    flush: function(async) {
        //async mode
        if (async || this.url === undefined || this.url === '') {
            return this.send_buf;
        }

        var xreq = this.getXmlHttpRequestObject();

        if (xreq.overrideMimeType) {
            xreq.overrideMimeType('application/json');
        }

        xreq.open('POST', this.url, false);
        xreq.send(this.send_buf);

        if (xreq.readyState != 4) {
            throw 'encountered an unknown ajax ready state: ' + xreq.readyState;
        }

        if (xreq.status != 200) {
            throw 'encountered a unknown request status: ' + xreq.status;
        }

        this.recv_buf = xreq.responseText;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    jqRequest: function(client, postData, args, recv_method) {
        if (typeof jQuery === 'undefined' ||
            typeof jQuery.Deferred === 'undefined') {
            throw 'Thrift.js requires jQuery 1.5+ to use asynchronous requests';
        }

        var thriftTransport = this;

        var jqXHR = jQuery.ajax({
            url: this.url,
            data: postData,
            type: 'POST',
            cache: false,
            contentType: 'application/json',
            dataType: 'text thrift',
            converters: {
                'text thrift' : function(responseData) {
                    thriftTransport.setRecvBuffer(responseData);
                    var value = recv_method.call(client);
                    return value;
                }
            },
            context: client,
            success: jQuery.makeArray(args).pop()
        });

        return jqXHR;
    },

    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    isOpen: function() {
        return true;
    },

    open: function() {},

    close: function() {},

    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    readAll: function() {
        return this.recv_buf;
    },

    write: function(buf) {
        this.send_buf = buf;
    },

    getSendBuffer: function() {
        return this.send_buf;
    }

};



Thrift.Protocol = function(transport) {
    this.transport = transport;
};

Thrift.Protocol.Type = {};
Thrift.Protocol.Type[Thrift.Type.BOOL] = '"tf"';
Thrift.Protocol.Type[Thrift.Type.BYTE] = '"i8"';
Thrift.Protocol.Type[Thrift.Type.I16] = '"i16"';
Thrift.Protocol.Type[Thrift.Type.I32] = '"i32"';
Thrift.Protocol.Type[Thrift.Type.I64] = '"i64"';
Thrift.Protocol.Type[Thrift.Type.DOUBLE] = '"dbl"';
Thrift.Protocol.Type[Thrift.Type.STRUCT] = '"rec"';
Thrift.Protocol.Type[Thrift.Type.STRING] = '"str"';
Thrift.Protocol.Type[Thrift.Type.MAP] = '"map"';
Thrift.Protocol.Type[Thrift.Type.LIST] = '"lst"';
Thrift.Protocol.Type[Thrift.Type.SET] = '"set"';


Thrift.Protocol.RType = {};
Thrift.Protocol.RType.tf = Thrift.Type.BOOL;
Thrift.Protocol.RType.i8 = Thrift.Type.BYTE;
Thrift.Protocol.RType.i16 = Thrift.Type.I16;
Thrift.Protocol.RType.i32 = Thrift.Type.I32;
Thrift.Protocol.RType.i64 = Thrift.Type.I64;
Thrift.Protocol.RType.dbl = Thrift.Type.DOUBLE;
Thrift.Protocol.RType.rec = Thrift.Type.STRUCT;
Thrift.Protocol.RType.str = Thrift.Type.STRING;
Thrift.Protocol.RType.map = Thrift.Type.MAP;
Thrift.Protocol.RType.lst = Thrift.Type.LIST;
Thrift.Protocol.RType.set = Thrift.Type.SET;

Thrift.Protocol.Version = 1;

Thrift.Protocol.prototype = {

    getTransport: function() {
        return this.transport;
    },

    //Write functions
    writeMessageBegin: function(name, messageType, seqid) {
        this.tstack = [];
        this.tpos = [];

        this.tstack.push([Thrift.Protocol.Version, '"' +
            name + '"', messageType, seqid]);
    },

    writeMessageEnd: function() {
        var obj = this.tstack.pop();

        this.wobj = this.tstack.pop();
        this.wobj.push(obj);

        this.wbuf = '[' + this.wobj.join(',') + ']';

        this.transport.write(this.wbuf);
     },


    writeStructBegin: function(name) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({});
    },

    writeStructEnd: function() {

        var p = this.tpos.pop();
        var struct = this.tstack[p];
        var str = '{';
        var first = true;
        for (var key in struct) {
            if (first) {
                first = false;
            } else {
                str += ',';
            }

            str += key + ':' + struct[key];
        }

        str += '}';
        this.tstack[p] = str;
    },

    writeFieldBegin: function(name, fieldType, fieldId) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({ 'fieldId': '"' +
            fieldId + '"', 'fieldType': Thrift.Protocol.Type[fieldType]
        });

    },

    writeFieldEnd: function() {
        var value = this.tstack.pop();
        var fieldInfo = this.tstack.pop();

        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
            fieldInfo.fieldType + ':' + value + '}';
        this.tpos.pop();
    },

    writeFieldStop: function() {
        //na
    },

    writeMapBegin: function(keyType, valType, size) {
        //size is invalid, we'll set it on end.
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[keyType],
            Thrift.Protocol.Type[valType], 0]);
    },

    writeMapEnd: function() {
        var p = this.tpos.pop();

        if (p == this.tstack.length) {
            return;
        }

        if ((this.tstack.length - p - 1) % 2 !== 0) {
            this.tstack.push('');
        }

        var size = (this.tstack.length - p - 1) / 2;

        this.tstack[p][this.tstack[p].length - 1] = size;

        var map = '}';
        var first = true;
        while (this.tstack.length > p + 1) {
            var v = this.tstack.pop();
            var k = this.tstack.pop();
            if (first) {
                first = false;
            } else {
                map = ',' + map;
            }

            if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
            map = k + ':' + v + map;
        }
        map = '{' + map;

        this.tstack[p].push(map);
        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    writeListBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    writeListEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    writeSetBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    writeSetEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    writeBool: function(value) {
        this.tstack.push(value ? 1 : 0);
    },

    writeByte: function(i8) {
        this.tstack.push(i8);
    },

    writeI16: function(i16) {
        this.tstack.push(i16);
    },

    writeI32: function(i32) {
        this.tstack.push(i32);
    },

    writeI64: function(i64) {
        this.tstack.push(i64);
    },

    writeDouble: function(dbl) {
        this.tstack.push(dbl);
    },

    writeString: function(str) {
        // We do not encode uri components for wire transfer:
        if (str === null) {
            this.tstack.push(null);
        } else {
            // concat may be slower than building a byte buffer
            var escapedString = '';
            for (var i = 0; i < str.length; i++) {
                var ch = str.charAt(i);      // a single double quote: "
                if (ch === '\"') {
                    escapedString += '\\\"'; // write out as: \"
                } else if (ch === '\\') {    // a single backslash: \
                    escapedString += '\\\\'; // write out as: \\
                /* Currently escaped forward slashes break TJSONProtocol.
                 * As it stands, we can simply pass forward slashes into
                 * our strings across the wire without being escaped.
                 * I think this is the protocol's bug, not thrift.js
                 * } else if(ch === '/') {   // a single forward slash: /
                 *  escapedString += '\\/';  // write out as \/
                 * }
                 */
                } else if (ch === '\b') {    // a single backspace: invisible
                    escapedString += '\\b';  // write out as: \b"
                } else if (ch === '\f') {    // a single formfeed: invisible
                    escapedString += '\\f';  // write out as: \f"
                } else if (ch === '\n') {    // a single newline: invisible
                    escapedString += '\\n';  // write out as: \n"
                } else if (ch === '\r') {    // a single return: invisible
                    escapedString += '\\r';  // write out as: \r"
                } else if (ch === '\t') {    // a single tab: invisible
                    escapedString += '\\t';  // write out as: \t"
                } else {
                    escapedString += ch;     // Else it need not be escaped
                }
            }
            this.tstack.push('"' + escapedString + '"');
        }
    },

    writeBinary: function(str) {
        this.writeString(str);
    },



    // Reading functions
    readMessageBegin: function(name, messageType, seqid) {
        this.rstack = [];
        this.rpos = [];

        if (typeof jQuery !== 'undefined') {
            this.robj = jQuery.parseJSON(this.transport.readAll());
        } else {
            this.robj = eval(this.transport.readAll());
        }

        var r = {};
        var version = this.robj.shift();

        if (version != Thrift.Protocol.Version) {
            throw 'Wrong thrift protocol version: ' + version;
        }

        r.fname = this.robj.shift();
        r.mtype = this.robj.shift();
        r.rseqid = this.robj.shift();


        //get to the main obj
        this.rstack.push(this.robj.shift());

        return r;
    },

    readMessageEnd: function() {
    },

    readStructBegin: function(name) {
        var r = {};
        r.fname = '';

        //incase this is an array of structs
        if (this.rstack[this.rstack.length - 1] instanceof Array) {
            this.rstack.push(this.rstack[this.rstack.length - 1].shift());
        }

        return r;
    },

    readStructEnd: function() {
        if (this.rstack[this.rstack.length - 2] instanceof Array) {
            this.rstack.pop();
        }
    },

    readFieldBegin: function() {
        var r = {};

        var fid = -1;
        var ftype = Thrift.Type.STOP;

        //get a fieldId
        for (var f in (this.rstack[this.rstack.length - 1])) {
            if (f === null) {
              continue;
            }

            fid = parseInt(f, 10);
            this.rpos.push(this.rstack.length);

            var field = this.rstack[this.rstack.length - 1][fid];

            //remove so we don't see it again
            delete this.rstack[this.rstack.length - 1][fid];

            this.rstack.push(field);

            break;
        }

        if (fid != -1) {

            //should only be 1 of these but this is the only
            //way to match a key
            for (var i in (this.rstack[this.rstack.length - 1])) {
                if (Thrift.Protocol.RType[i] === null) {
                    continue;
                }

                ftype = Thrift.Protocol.RType[i];
                this.rstack[this.rstack.length - 1] =
                    this.rstack[this.rstack.length - 1][i];
            }
        }

        r.fname = '';
        r.ftype = ftype;
        r.fid = fid;

        return r;
    },

    readFieldEnd: function() {
        var pos = this.rpos.pop();

        //get back to the right place in the stack
        while (this.rstack.length > pos) {
            this.rstack.pop();
        }

    },

    readMapBegin: function(keyType, valType, size) {
        var map = this.rstack.pop();

        var r = {};
        r.ktype = Thrift.Protocol.RType[map.shift()];
        r.vtype = Thrift.Protocol.RType[map.shift()];
        r.size = map.shift();


        this.rpos.push(this.rstack.length);
        this.rstack.push(map.shift());

        return r;
    },

    readMapEnd: function() {
        this.readFieldEnd();
    },

    readListBegin: function(elemType, size) {
        var list = this.rstack[this.rstack.length - 1];

        var r = {};
        r.etype = Thrift.Protocol.RType[list.shift()];
        r.size = list.shift();

        this.rpos.push(this.rstack.length);
        this.rstack.push(list);

        return r;
    },

    readListEnd: function() {
        this.readFieldEnd();
    },

    readSetBegin: function(elemType, size) {
        return this.readListBegin(elemType, size);
    },

    readSetEnd: function() {
        return this.readListEnd();
    },

    readBool: function() {
        var r = this.readI32();

        if (r !== null && r.value == '1') {
            r.value = true;
        } else {
            r.value = false;
        }

        return r;
    },

    readByte: function() {
        return this.readI32();
    },

    readI16: function() {
        return this.readI32();
    },

    readI32: function(f) {
        if (f === undefined) {
            f = this.rstack[this.rstack.length - 1];
        }

        var r = {};

        if (f instanceof Array) {
            if (f.length === 0) {
                r.value = undefined;
            } else {
                r.value = f.shift();
            }
        } else if (f instanceof Object) {
           for (var i in f) {
                if (i === null) {
                  continue;
                }
                this.rstack.push(f[i]);
                delete f[i];

                r.value = i;
                break;
           }
        } else {
            r.value = f;
            this.rstack.pop();
        }

        return r;
    },

    readI64: function() {
        return this.readI32();
    },

    readDouble: function() {
        return this.readI32();
    },

    readString: function() {
        var r = this.readI32();
        return r;
    },

    readBinary: function() {
        return this.readString();
    },


    //Method to arbitrarily skip over data.
    skip: function(type) {
        throw 'skip not supported yet';
    }
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


StatusT = {
'StatusOk' : 0,
'StatusPerm' : 1,
'StatusNoEnt' : 2,
'StatusSrch' : 3,
'StatusIntr' : 4,
'StatusIO' : 5,
'StatusNxIO' : 6,
'Status2Big' : 7,
'StatusNoExec' : 8,
'StatusBadF' : 9,
'StatusChild' : 10,
'StatusAgain' : 11,
'StatusNoMem' : 12,
'StatusAccess' : 13,
'StatusFault' : 14,
'StatusNotBlk' : 15,
'StatusBusy' : 16,
'StatusExist' : 17,
'StatusXDev' : 18,
'StatusNoDev' : 19,
'StatusNotDir' : 20,
'StatusIsDir' : 21,
'StatusInval' : 22,
'StatusNFile' : 23,
'StatusMFile' : 24,
'StatusNoTTY' : 25,
'StatusTxtBsy' : 26,
'StatusFBig' : 27,
'StatusNoSpc' : 28,
'StatusSPipe' : 29,
'StatusROFS' : 30,
'StatusMLink' : 31,
'StatusPipe' : 32,
'StatusDom' : 33,
'StatusRange' : 34,
'StatusDeadLk' : 35,
'StatusNameTooLong' : 36,
'StatusNoLck' : 37,
'StatusNoSys' : 38,
'StatusNotEmpty' : 39,
'StatusLoop' : 40,
'StatusNoMsg' : 41,
'StatusIdRm' : 42,
'StatusChRng' : 43,
'StatusL2NSync' : 44,
'StatusL3Hlt' : 45,
'StatusL3Rst' : 46,
'StatusLNRng' : 47,
'StatusUnatch' : 48,
'StatusNoCSI' : 49,
'StatusL2Hlt' : 50,
'StatusBadE' : 51,
'StatusBadR' : 52,
'StatusXFull' : 53,
'StatusNoAno' : 54,
'StatusBadRqC' : 55,
'StatusBadSlt' : 56,
'StatusBFont' : 57,
'StatusNoStr' : 58,
'StatusNoData' : 59,
'StatusTime' : 60,
'StatusNoSR' : 61,
'StatusNoNet' : 62,
'StatusNoPkg' : 63,
'StatusRemote' : 64,
'StatusNoLink' : 65,
'StatusAdv' : 66,
'StatusSRMnt' : 67,
'StatusComm' : 68,
'StatusProto' : 69,
'StatusMultihop' : 70,
'StatusDotDot' : 71,
'StatusBadMsg' : 72,
'StatusOverflow' : 73,
'StatusNotUniq' : 74,
'StatusBadFD' : 75,
'StatusRemChg' : 76,
'StatusLibAcc' : 77,
'StatusLibBad' : 78,
'StatusLibScn' : 79,
'StatusLibMax' : 80,
'StatusLibExec' : 81,
'StatusIlSeq' : 82,
'StatusRestart' : 83,
'StatusStrPipe' : 84,
'StatusUsers' : 85,
'StatusNotSock' : 86,
'StatusDestAddrReq' : 87,
'StatusMsgSize' : 88,
'StatusPrototype' : 89,
'StatusNoProtoOpt' : 90,
'StatusProtoNoSupport' : 91,
'StatusSockTNoSupport' : 92,
'StatusOpNotSupp' : 93,
'StatusPFNoSupport' : 94,
'StatusAFNoSupport' : 95,
'StatusAddrInUse' : 96,
'StatusAddrNotAvail' : 97,
'StatusNetDown' : 98,
'StatusNetUnreach' : 99,
'StatusNetReset' : 100,
'StatusConnAborted' : 101,
'StatusConnReset' : 102,
'StatusNoBufs' : 103,
'StatusIsConn' : 104,
'StatusNotConn' : 105,
'StatusShutdown' : 106,
'StatusTooManyRefs' : 107,
'StatusTimedOut' : 108,
'StatusConnRefused' : 109,
'StatusHostDown' : 110,
'StatusHostUnreach' : 111,
'StatusAlready' : 112,
'StatusInProgress' : 113,
'StatusStale' : 114,
'StatusUClean' : 115,
'StatusNotNam' : 116,
'StatusNAvail' : 117,
'StatusIsNam' : 118,
'StatusRemoteIo' : 119,
'StatusDQuot' : 120,
'StatusNoMedium' : 121,
'StatusMediumType' : 122,
'StatusCanceled' : 123,
'StatusNoKey' : 124,
'StatusKeyExpired' : 125,
'StatusKeyRevoked' : 126,
'StatusKeyRejected' : 127,
'StatusOwnerDead' : 128,
'StatusNotRecoverable' : 129,
'StatusRFKill' : 130,
'StatusHwPoison' : 131,
'StatusTrunc' : 132,
'StatusUnimpl' : 133,
'StatusUnknown' : 134,
'StatusMsgLibDeleteFailed' : 135,
'StatusThrCreateFailed' : 136,
'StatusThrAborted' : 137,
'StatusConfigLibDevOpenFailed' : 138,
'StatusConfigLibDevLSeekFailed' : 139,
'StatusConfigLibFlashDevOpenFailed' : 140,
'StatusConfigLibFlashDevLSeekFailed' : 141,
'StatusConfigLibDeleteFailed' : 142,
'StatusUsrNodeIncorrectParams' : 143,
'StatusUnicodeUnsupported' : 144,
'StatusEAIBadFlags' : 145,
'StatusEAINoName' : 146,
'StatusEAIFail' : 147,
'StatusEAIService' : 148,
'StatusEAINoData' : 149,
'StatusEAIAddrFamily' : 150,
'StatusEAINotCancel' : 151,
'StatusEAIAllDone' : 152,
'StatusEAIIDNEncode' : 153,
'StatusLast' : 154,
'StatusMore' : 155,
'StatusCliUnknownCmd' : 156,
'StatusCliParseError' : 157,
'StatusSchedQueueLenExceeded' : 158,
'StatusMsgFail' : 159,
'StatusMsgOutOfMessages' : 160,
'StatusMsgShutdown' : 161,
'StatusNoSuchNode' : 162,
'StatusNewTableCreated' : 163,
'StatusNoSuchResultSet' : 164,
'StatusDfAppendUnsupported' : 165,
'StatusDfRemoveUnsupported' : 166,
'StatusDfParseError' : 167,
'StatusDfRecordCorrupt' : 168,
'StatusDfFieldNoExist' : 169,
'StatusDfUnknownFieldType' : 170,
'StatusDfRecordNotFound' : 171,
'StatusDfValNotFound' : 172,
'StatusDfInvalidFormat' : 173,
'StatusDfLocalFatptrOnly' : 174,
'StatusDfValuesBufTooSmall' : 175,
'StatusDfMaxValuesPerFieldExceeded' : 176,
'StatusDfFieldTypeUnsupported' : 177,
'StatusDfMaxDictionarySegmentsExceeded' : 178,
'StatusDfBadRecordId' : 179,
'StatusDfMaxRecordsExceeded' : 180,
'StatusDfTypeMismatch' : 181,
'StatusDsTooManyKeyValues' : 182,
'StatusDsNotFound' : 183,
'StatusDsLoadAlreadyStarted' : 184,
'StatusDsUrlTooLong' : 185,
'StatusDsInvalidUrl' : 186,
'StatusDsCreateNotSupported' : 187,
'StatusDsUnlinkNotSupported' : 188,
'StatusDsLoadFailed' : 189,
'StatusDsDatasetInUse' : 190,
'StatusDsFormatTypeUnsupported' : 191,
'StatusDsMysqlInitFailed' : 192,
'StatusDsMysqlConnectFailed' : 193,
'StatusDsMysqlQueryFailed' : 194,
'StatusReallocShrinkFailed' : 195,
'StatusNsObjAlreadyExists' : 196,
'StatusTableAlreadyExists' : 197,
'StatusCliUnclosedQuotes' : 198,
'StatusRangePartError' : 199,
'StatusNewFieldNameIsBlank' : 200,
'StatusNoDataDictForFormatType' : 201,
'StatusBTreeNotFound' : 202,
'StatusBTreeKeyTypeMismatch' : 203,
'StatusBTreeDatasetMismatch' : 204,
'StatusCmdNotComplete' : 205,
'StatusInvalidResultSetId' : 206,
'StatusPositionExceedResultSetSize' : 207,
'StatusHandleInUse' : 208,
'StatusCliLineTooLong' : 209,
'StatusCliErrorReadFromFile' : 210,
'StatusInvalidTableName' : 211,
'StatusNsObjNameTooLong' : 212,
'StatusApiUnexpectedEOF' : 213,
'StatusStatsInvalidGroupId' : 214,
'StatusStatsInvalidGroupName' : 215,
'StatusInvalidHandle' : 216,
'StatusThriftProtocolError' : 217,
'StatusBTreeHasNoRoot' : 218,
'StatusBTreeKeyNotFound' : 219,
'StatusQaKeyValuePairNotFound' : 220,
'StatusAstMalformedEvalString' : 221,
'StatusAstNoSuchFunction' : 222,
'StatusFieldNameTooLong' : 223,
'StatusFieldNameAlreadyExists' : 224,
'StatusXdfWrongNumberOfArgs' : 225,
'StatusXdfUnaryOperandExpected' : 226,
'StatusXdfTypeUnsupported' : 227,
'StatusXdfDivByZero' : 228,
'StatusKvNotFound' : 229,
'StatusXdbSlotPrettyVacant' : 230,
'StatusNoDataInXdb' : 231,
'StatusXdbNotFound' : 232,
'StatusXdbUninitializedCursor' : 233,
'StatusQrTaskFailed' : 234,
'StatusQrIdNonExist' : 235,
'StatusQrJobNonExist' : 236,
'StatusApiTaskFailed' : 237,
'StatusAlreadyIndexed' : 238,
'StatusEvalUnsubstitutedVariables' : 239,
'StatusKvDstFull' : 240,
'StatusModuleNotInit' : 241,
'StatusMaxJoinFieldsExceeded' : 242,
'StatusXdbKeyTypeAlreadySet' : 243,
'StatusJoinTypeMismatch' : 244,
'StatusFailed' : 245,
'StatusIllegalFileName' : 246,
'StatusEmptyFile' : 247,
'StatusEvalStringTooLong' : 248,
'StatusTableDeleted' : 249,
'StatusFailOpenFile' : 250,
'StatusQueryFailed' : 251,
'StatusCreateDagNodeFailed' : 252,
'StatusAggregateNoSuchField' : 253,
'StatusAggregateLocalFnNeedArgument' : 254,
'StatusAggregateAccNotInited' : 255,
'StatusNsMaximumObjectsReached' : 256,
'StatusNsObjInUse' : 257,
'StatusNsInvalidObjName' : 258,
'StatusNsNotFound' : 259,
'StatusDagNodeNotFound' : 260,
'StatusUpdateDagNodeOperationNotSupported' : 261,
'StatusMsgMaxPayloadExceeded' : 262
};
StatusTStr = {0 : 'Success',
1 : 'Operation not permitted',
2 : 'No such file or directory',
3 : 'No such process',
4 : 'Interrupted system call',
5 : 'I/O error',
6 : 'No such device or address',
7 : 'Argument list too long',
8 : 'Exec format error',
9 : 'Bad file number',
10 : 'No child processes',
11 : 'Try again',
12 : 'Out of memory',
13 : 'Permission denied',
14 : 'Bad address',
15 : 'Block device required',
16 : 'Device or resource busy',
17 : 'File exists',
18 : 'Cross-device link',
19 : 'No such device',
20 : 'Not a directory',
21 : 'Is a directory',
22 : 'Invalid argument',
23 : 'File table overflow',
24 : 'Too many open files',
25 : 'Not a typewriter',
26 : 'Text file busy',
27 : 'File too large',
28 : 'No space left on device',
29 : 'Illegal seek',
30 : 'Read-only file system',
31 : 'Too many links',
32 : 'Broken pipe',
33 : 'Math argument out of domain of func',
34 : 'Math result not representable',
35 : 'Resource deadlock would occur',
36 : 'File name too long',
37 : 'No record locks available',
38 : 'Function not implemented',
39 : 'Directory not empty',
40 : 'Too many symbolic links encountered',
41 : 'No message of desired type',
42 : 'Identifier removed',
43 : 'Channel number out of range',
44 : 'Level 2 not synchronized',
45 : 'Level 3 halted',
46 : 'Level 3 reset',
47 : 'Link number out of range',
48 : 'Protocol driver not attached',
49 : 'No CSI structure available',
50 : 'Level 2 halted',
51 : 'Invalid exchange',
52 : 'Invalid request descriptor',
53 : 'Exchange full',
54 : 'No anode',
55 : 'Invalid request code',
56 : 'Invalid slot',
57 : 'Bad font file format',
58 : 'Device not a stream',
59 : 'No data available',
60 : 'Timer expired',
61 : 'Out of streams resources',
62 : 'Machine is not on the network',
63 : 'Package not installed',
64 : 'Object is remote',
65 : 'Link has been severed',
66 : 'Advertise error',
67 : 'Srmount error',
68 : 'Communication error on send',
69 : 'Protocol error',
70 : 'Multihop attempted',
71 : 'RFS specific error',
72 : 'Not a data message',
73 : 'Value too large for defined data type',
74 : 'Name not unique on network',
75 : 'File descriptor in bad state',
76 : 'Remote address changed',
77 : 'Can not access a needed shared library',
78 : 'Accessing a corrupted shared library',
79 : '.lib section in a.out corrupted',
80 : 'Attempting to link in too many shared libraries',
81 : 'Cannot exec a shared library directly',
82 : 'Illegal byte sequence',
83 : 'Interrupted system call should be restarted',
84 : 'Streams pipe error',
85 : 'Too many users',
86 : 'Socket operation on non-socket',
87 : 'Destination address required',
88 : 'Message too long',
89 : 'Protocol wrong type for socket',
90 : 'Protocol not available',
91 : 'Protocol not supported',
92 : 'Socket type not supported',
93 : 'Operation not supported on transport endpoint',
94 : 'Protocol family not supported',
95 : 'Address family not supported by protocol',
96 : 'Address already in use',
97 : 'Cannot assign requested address',
98 : 'Network is down',
99 : 'Network is unreachable',
100 : 'Network dropped connection because of reset',
101 : 'Software caused connection abort',
102 : 'Connection reset by peer',
103 : 'No buffer space available',
104 : 'Transport endpoint is already connected',
105 : 'Transport endpoint is not connected',
106 : 'Cannot send after transport endpoint shutdown',
107 : 'Too many references: cannot splice',
108 : 'Connection timed out',
109 : 'Connection refused',
110 : 'Host is down',
111 : 'No route to host',
112 : 'Operation already in progress',
113 : 'Operation now in progress',
114 : 'Stale NFS file handle',
115 : 'Structure needs cleaning',
116 : 'Not a XENIX named type file',
117 : 'No XENIX semaphores available',
118 : 'Is a named type file',
119 : 'Remote I/O error',
120 : 'Quota exceeded',
121 : 'No medium found',
122 : 'Wrong medium type',
123 : 'Operation Canceled',
124 : 'Required key not available',
125 : 'Key has expired',
126 : 'Key has been revoked',
127 : 'Key was rejected by service',
128 : 'Owner died',
129 : 'State not recoverable',
130 : 'Operation not possible due to RF-kill',
131 : 'Memory page has hardware error',
132 : 'Output truncated',
133 : 'Not implemented',
134 : 'Unknown error',
135 : 'msgLib delete() failed',
136 : 'thrCreate() failed',
137 : 'Thread was aborted',
138 : 'libConfig open() failed',
139 : 'libConfig lseek() failed',
140 : 'libConfig flash open() failed',
141 : 'libConfig flash lseek() failed',
142 : 'libConfig configDelete() failed',
143 : 'Incorrect params to UsrNodeMain',
144 : 'Unicode strings are not supported by this function',
145 : 'Invalid value for ai_flags field',
146 : 'NAME or SERVICE is unknown',
147 : 'Non-recoverable failure in name resolution',
148 : 'SERVICE not supported for socket type',
149 : 'No address associated with NAME',
150 : 'Address family for NAME not supported',
151 : 'Request not canceled',
152 : 'All requests done',
153 : 'IDN encoding failed',
154 : 'Last page',
155 : 'More data to follow. Not end of stream',
156 : 'Command not found',
157 : 'Error parsing command',
158 : 'Sched queue length exceeded',
159 : 'Failure in the message layer',
160 : 'Out of messages',
161 : 'Shutdown message',
162 : 'No such node exists in cluster',
163 : 'New table created',
164 : 'No such result set',
165 : 'Data format does not support appending fields',
166 : 'Data format does not support removing fields',
167 : 'Failed to parse data format value',
168 : 'Record data format is corrupt',
169 : 'Field does not exist within record',
170 : 'Unknown field type',
171 : 'Failed to find a record corresponding to the given record number',
172 : 'Searched value was not found',
173 : 'Invalid data format',
174 : 'Context does not support dereferencing a remote Fatptr',
175 : 'Values buffer is too small to store even a single field value',
176 : 'Too many values discovered for a single field',
177 : 'Field type is not supported in this format',
178 : 'Maximum number of dictionary segments reached',
179 : 'Bad record identifier',
180 : 'System has exceeded the configured maximum number of records; try increasing Constants.DfMaxRecords',
181 : 'Type mismatch during index creation',
182 : 'Intended key has more than a single',
183 : 'Dataset not found',
184 : 'Loading of this dataset has already started',
185 : 'URL length is too large',
186 : 'URL is not valid',
187 : 'Data source type does not support file creation',
188 : 'Data source type does not support file deletion',
189 : 'Loading of this dataset failed',
190 : 'Dataset is in use',
191 : 'Data source does not support specified data format type',
192 : 'Failed to initialize the mysql client library',
193 : 'Failed to connect to mysql server & database',
194 : 'Failed to run query against mysql table',
195 : 'Failed to shrink memory allocation',
196 : 'Table or dataset already exists',
197 : 'Table already exists',
198 : 'Invalid command. Could not find matching quotes',
199 : 'Failed to compute the range partition hash function',
200 : 'Field name cannot be blank',
201 : 'No data dictionary defined for format type',
202 : 'Could not find BTree associated with table handle',
203 : 'BTree key type does not match insert message key type',
204 : 'BTree dataset identifier does not match insert message dataset identifier',
205 : 'Command is still running',
206 : 'Invalid result set ID',
207 : 'Cannot set position to beyond result set size',
208 : 'Table is in use right now and cannot be deleted',
209 : 'One of the lines in the CLI is too long',
210 : 'Encountered an error reading from file',
211 : 'Invalid table name',
212 : 'Table or dataset name is too long',
213 : 'Unexpected end-of-file attempting to read from socket',
214 : 'stats group ID is invalid',
215 : 'stats group name is invalid',
216 : 'Invalid handle',
217 : 'Error communicating across thrift connection',
218 : 'Malformed BTree. BTree has no root',
219 : 'Could not find key in BTree',
220 : 'Could not find key-value pair',
221 : 'Malformed eval string',
222 : 'Could not find function',
223 : 'The new field name is too long',
224 : 'The field name you entered already exists',
225 : 'Wrong number of operands provided to operator',
226 : 'Operation requires 1 operand',
227 : 'Operation is not supported on input type',
228 : 'Divide by zero error',
229 : 'KV not found in table',
230 : 'Listen to: Pretty Vacant by Sex Pistols',
231 : 'Xdb is vacant',
232 : 'Stale XdbHandle, Xdb not found',
233 : 'Xdb cursor is uninitialized',
234 : 'Task(s) failed',
235 : 'The query ID is not existed',
236 : 'There is no query job associate with this ID',
237 : 'API Task Failed',
238 : 'The source table is already indexed by the specified key',
239 : 'Some variables are undefined during evaluation',
240 : 'The destination key/value buffer was full',
241 : 'The module is not initialized yet',
242 : 'Maximum number of joined values exceeded',
243 : 'Xdb key type is already set',
244 : 'Joins may only be performed on tables with the same key type',
245 : 'Failed',
246 : 'FileName entered is illegal',
247 : 'File contents are empty',
248 : 'Eval string entered is too long',
249 : 'Table has been deleted',
250 : 'Cant open the file',
251 : 'Query failed',
252 : 'Failed to create a Dag Node',
253 : 'No such field found while running aggregate',
254 : 'Local function requires argument',
255 : 'Accumulator is not inited',
256 : 'Maximum number of tables and datasets reached',
257 : 'Table or dataset is in use',
258 : 'Bad table or dataset name',
259 : 'Table or dataset not found',
260 : 'Could not find dag node',
261 : 'Update operation not supported',
262 : 'Message response size would exceed maximum message payload size'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


XcalarApiVersionT = {
'XcalarApiVersionSignature' : 54520027
};
XcalarApiVersionTStr = {54520027 : '33fe8db67bee195984433f49cc1a403d'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


DfFieldTypeT = {
'DfUnknown' : 0,
'DfString' : 1,
'DfInt32' : 2,
'DfUInt32' : 3,
'DfInt64' : 4,
'DfUInt64' : 5,
'DfFloat32' : 6,
'DfFloat64' : 7,
'DfBoolean' : 8,
'DfTimespec' : 9,
'DfBlob' : 10,
'DfNull' : 11,
'DfMixed' : 12,
'DfFatptr' : 13
};
DfFormatTypeT = {
'DfTypeUnknown' : 0,
'DfTypeJson' : 1,
'DfTypeRandom' : 2,
'DfTypeCsv' : 3,
'DfTypeMysql' : 4
};
DfFieldTypeTStr = {0 : 'DfUnknown',
1 : 'DfString',
2 : 'DfInt32',
3 : 'DfUInt32',
4 : 'DfInt64',
5 : 'DfUInt64',
6 : 'DfFloat32',
7 : 'DfFloat64',
8 : 'DfBoolean',
9 : 'DfTimespec',
10 : 'DfBlob',
11 : 'DfNull',
12 : 'DfMixed',
13 : 'DfFatptr'
};
DfFormatTypeTStr = {0 : 'unknown',
1 : 'json',
2 : 'random',
3 : 'csv',
4 : 'mysql'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


XcalarApisT = {
'XcalarApiUnknown' : 0,
'XcalarApiGetVersion' : 1,
'XcalarApiBulkLoad' : 2,
'XcalarApiIndex' : 3,
'XcalarApiCountUnique' : 4,
'XcalarApiShutdown' : 5,
'XcalarApiGetStat' : 6,
'XcalarApiGetStatByGroupId' : 7,
'XcalarApiResetStat' : 8,
'XcalarApiGetStatGroupIdMap' : 9,
'XcalarApiListTables' : 10,
'XcalarApiListDatasets' : 11,
'XcalarApiShutdownLocal' : 12,
'XcalarApiMakeResultSet' : 13,
'XcalarApiResultSetNext' : 14,
'XcalarApiJoin' : 15,
'XcalarApiFilter' : 16,
'XcalarApiGroupBy' : 17,
'XcalarApiGetDataDict' : 18,
'XcalarApiEditColumn' : 19,
'XcalarApiResultSetAbsolute' : 20,
'XcalarApiFreeResultSet' : 21,
'XcalarApiDeleteTable' : 22,
'XcalarApiGetTableRefCount' : 23,
'XcalarApiBulkDeleteTables' : 24,
'XcalarApiDestroyDataset' : 25,
'XcalarApiMap' : 26,
'XcalarApiAggregate' : 27,
'XcalarApiQuery' : 28,
'XcalarApiQueryState' : 29,
'XcalarApiExport' : 30,
'XcalarApiGetDag' : 31,
'XcalarApiListFiles' : 32,
'XcalarApiStartNodes' : 33,
'XcalarApiMakeRetina' : 34,
'XcalarApiListRetinas' : 35,
'XcalarApiGetRetina' : 36,
'XcalarApiUpdateRetina' : 37,
'XcalarApiAddParameterToRetina' : 38,
'XcalarApiListParametersInRetina' : 39,
'XcalarApiExecuteRetina' : 40
};
XcalarApisTStr = {0 : 'XcalarApiUnknown',
1 : 'XcalarApiGetVersion',
2 : 'XcalarApiBulkLoad',
3 : 'XcalarApiIndex',
4 : 'XcalarApiCountUnique',
5 : 'XcalarApiShutdown',
6 : 'XcalarApiGetStat',
7 : 'XcalarApiGetStatByGroupId',
8 : 'XcalarApiResetStat',
9 : 'XcalarApiGetStatGroupIdMap',
10 : 'XcalarApiListTables',
11 : 'XcalarApiListDatasets',
12 : 'XcalarApiShutdownLocal',
13 : 'XcalarApiMakeResultSet',
14 : 'XcalarApiResultSetNext',
15 : 'XcalarApiJoin',
16 : 'XcalarApiFilter',
17 : 'XcalarApiGroupBy',
18 : 'XcalarApiGetDataDict',
19 : 'XcalarApiEditColumn',
20 : 'XcalarApiResultSetAbsolute',
21 : 'XcalarApiFreeResultSet',
22 : 'XcalarApiDeleteTable',
23 : 'XcalarApiGetTableRefCount',
24 : 'XcalarApiBulkDeleteTables',
25 : 'XcalarApiDestroyDataset',
26 : 'XcalarApiMap',
27 : 'XcalarApiAggregate',
28 : 'XcalarApiQuery',
29 : 'XcalarApiQueryState',
30 : 'XcalarApiExport',
31 : 'XcalarApiGetDag',
32 : 'XcalarApiListFiles',
33 : 'XcalarApiStartNodes',
34 : 'XcalarApiMakeRetina',
35 : 'XcalarApiListRetinas',
36 : 'XcalarApiGetRetina',
37 : 'XcalarApiUpdateRetina',
38 : 'XcalarApiAddParameterToRetina',
39 : 'XcalarApiListParametersInRetina',
40 : 'XcalarApiExecuteRetina'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


XcalarApisConstantsT = {
'XcalarApiMaxEvalStringLen' : 1024,
'XcalarApiMaxNumParameters' : 20
};
XcalarApisConstantsTStr = {1024 : 'XcalarApiMaxEvalStringLen',
20 : 'XcalarApiMaxNumParameters'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


AggregateOperatorT = {
'AggrMax' : 0,
'AggrMin' : 1,
'AggrSumKeys' : 2,
'AggrCountKeys' : 3,
'AggrAverage' : 4
};
AggregateOperatorTStr = {0 : 'max',
1 : 'min',
2 : 'sum',
3 : 'count',
4 : 'avg'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


JoinOperatorT = {
'InnerJoin' : 0,
'LeftOuterJoin' : 1,
'RightOuterJoin' : 2,
'FullOuterJoin' : 3
};
JoinOperatorTStr = {0 : 'innerJoin',
1 : 'leftJoin',
2 : 'rightJoin',
3 : 'fullOuterJoin'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


GenericTypesRecordTypeT = {
'GenericTypesFixedSize' : 0,
'GenericTypesVariableSize' : 1
};
GenericTypesRecordTypeTStr = {0 : 'GenericTypesFixedSize',
1 : 'GenericTypesVariableSize'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


XcalarApiException = function(args) {
  this.status = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
  }
};
Thrift.inherits(XcalarApiException, Thrift.TException);
XcalarApiException.prototype.name = 'XcalarApiException';
XcalarApiException.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiException.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiException');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

DfFieldAttrHeaderT = function(args) {
  this.name = null;
  this.type = null;
  if (args) {
    if (args.name !== undefined) {
      this.name = args.name;
    }
    if (args.type !== undefined) {
      this.type = args.type;
    }
  }
};
DfFieldAttrHeaderT.prototype = {};
DfFieldAttrHeaderT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DfFieldAttrHeaderT.prototype.write = function(output) {
  output.writeStructBegin('DfFieldAttrHeaderT');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 2);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

KeyValuePairFixedT = function(args) {
  this.key = null;
  this.value = null;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.value !== undefined) {
      this.value = args.value;
    }
  }
};
KeyValuePairFixedT.prototype = {};
KeyValuePairFixedT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.key = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.value = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KeyValuePairFixedT.prototype.write = function(output) {
  output.writeStructBegin('KeyValuePairFixedT');
  if (this.key !== null && this.key !== undefined) {
    output.writeFieldBegin('key', Thrift.Type.I64, 1);
    output.writeI64(this.key);
    output.writeFieldEnd();
  }
  if (this.value !== null && this.value !== undefined) {
    output.writeFieldBegin('value', Thrift.Type.I64, 2);
    output.writeI64(this.value);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

KeyValuePairVariableT = function(args) {
  this.key = null;
  this.valueSize = null;
  this.value = null;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.valueSize !== undefined) {
      this.valueSize = args.valueSize;
    }
    if (args.value !== undefined) {
      this.value = args.value;
    }
  }
};
KeyValuePairVariableT.prototype = {};
KeyValuePairVariableT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.key = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.valueSize = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.value = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KeyValuePairVariableT.prototype.write = function(output) {
  output.writeStructBegin('KeyValuePairVariableT');
  if (this.key !== null && this.key !== undefined) {
    output.writeFieldBegin('key', Thrift.Type.I64, 1);
    output.writeI64(this.key);
    output.writeFieldEnd();
  }
  if (this.valueSize !== null && this.valueSize !== undefined) {
    output.writeFieldBegin('valueSize', Thrift.Type.I64, 2);
    output.writeI64(this.valueSize);
    output.writeFieldEnd();
  }
  if (this.value !== null && this.value !== undefined) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 3);
    output.writeString(this.value);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

KeyValuePairT = function(args) {
  this.kvPairFixed = null;
  this.kvPairVariable = null;
  if (args) {
    if (args.kvPairFixed !== undefined) {
      this.kvPairFixed = args.kvPairFixed;
    }
    if (args.kvPairVariable !== undefined) {
      this.kvPairVariable = args.kvPairVariable;
    }
  }
};
KeyValuePairT.prototype = {};
KeyValuePairT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvPairFixed = new KeyValuePairFixedT();
        this.kvPairFixed.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvPairVariable = new KeyValuePairVariableT();
        this.kvPairVariable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KeyValuePairT.prototype.write = function(output) {
  output.writeStructBegin('KeyValuePairT');
  if (this.kvPairFixed !== null && this.kvPairFixed !== undefined) {
    output.writeFieldBegin('kvPairFixed', Thrift.Type.STRUCT, 1);
    this.kvPairFixed.write(output);
    output.writeFieldEnd();
  }
  if (this.kvPairVariable !== null && this.kvPairVariable !== undefined) {
    output.writeFieldBegin('kvPairVariable', Thrift.Type.STRUCT, 2);
    this.kvPairVariable.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

KeyValuePairsT = function(args) {
  this.recordType = null;
  this.totalRecordsSize = null;
  this.numRecords = null;
  this.records = null;
  if (args) {
    if (args.recordType !== undefined) {
      this.recordType = args.recordType;
    }
    if (args.totalRecordsSize !== undefined) {
      this.totalRecordsSize = args.totalRecordsSize;
    }
    if (args.numRecords !== undefined) {
      this.numRecords = args.numRecords;
    }
    if (args.records !== undefined) {
      this.records = args.records;
    }
  }
};
KeyValuePairsT.prototype = {};
KeyValuePairsT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.recordType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.totalRecordsSize = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.numRecords = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        var _size0 = 0;
        var _rtmp34;
        this.records = [];
        var _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var elem6 = null;
          elem6 = new KeyValuePairT();
          elem6.read(input);
          this.records.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

KeyValuePairsT.prototype.write = function(output) {
  output.writeStructBegin('KeyValuePairsT');
  if (this.recordType !== null && this.recordType !== undefined) {
    output.writeFieldBegin('recordType', Thrift.Type.I32, 1);
    output.writeI32(this.recordType);
    output.writeFieldEnd();
  }
  if (this.totalRecordsSize !== null && this.totalRecordsSize !== undefined) {
    output.writeFieldBegin('totalRecordsSize', Thrift.Type.I64, 2);
    output.writeI64(this.totalRecordsSize);
    output.writeFieldEnd();
  }
  if (this.numRecords !== null && this.numRecords !== undefined) {
    output.writeFieldBegin('numRecords', Thrift.Type.I32, 3);
    output.writeI32(this.numRecords);
    output.writeFieldEnd();
  }
  if (this.records !== null && this.records !== undefined) {
    output.writeFieldBegin('records', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.records.length);
    for (var iter7 in this.records)
    {
      if (this.records.hasOwnProperty(iter7))
      {
        iter7 = this.records[iter7];
        iter7.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiFileAttrT = function(args) {
  this.isDirectory = null;
  this.size = null;
  if (args) {
    if (args.isDirectory !== undefined) {
      this.isDirectory = args.isDirectory;
    }
    if (args.size !== undefined) {
      this.size = args.size;
    }
  }
};
XcalarApiFileAttrT.prototype = {};
XcalarApiFileAttrT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.isDirectory = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.size = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiFileAttrT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiFileAttrT');
  if (this.isDirectory !== null && this.isDirectory !== undefined) {
    output.writeFieldBegin('isDirectory', Thrift.Type.BOOL, 1);
    output.writeBool(this.isDirectory);
    output.writeFieldEnd();
  }
  if (this.size !== null && this.size !== undefined) {
    output.writeFieldBegin('size', Thrift.Type.I64, 2);
    output.writeI64(this.size);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiFileT = function(args) {
  this.attr = null;
  this.name = null;
  if (args) {
    if (args.attr !== undefined) {
      this.attr = args.attr;
    }
    if (args.name !== undefined) {
      this.name = args.name;
    }
  }
};
XcalarApiFileT.prototype = {};
XcalarApiFileT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.attr = new XcalarApiFileAttrT();
        this.attr.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiFileT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiFileT');
  if (this.attr !== null && this.attr !== undefined) {
    output.writeFieldBegin('attr', Thrift.Type.STRUCT, 1);
    this.attr.write(output);
    output.writeFieldEnd();
  }
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 2);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiListFilesInputT = function(args) {
  this.url = null;
  if (args) {
    if (args.url !== undefined) {
      this.url = args.url;
    }
  }
};
XcalarApiListFilesInputT.prototype = {};
XcalarApiListFilesInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.url = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiListFilesInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiListFilesInputT');
  if (this.url !== null && this.url !== undefined) {
    output.writeFieldBegin('url', Thrift.Type.STRING, 1);
    output.writeString(this.url);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiListFilesOutputT = function(args) {
  this.status = null;
  this.numFiles = null;
  this.files = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.numFiles !== undefined) {
      this.numFiles = args.numFiles;
    }
    if (args.files !== undefined) {
      this.files = args.files;
    }
  }
};
XcalarApiListFilesOutputT.prototype = {};
XcalarApiListFilesOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numFiles = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size8 = 0;
        var _rtmp312;
        this.files = [];
        var _etype11 = 0;
        _rtmp312 = input.readListBegin();
        _etype11 = _rtmp312.etype;
        _size8 = _rtmp312.size;
        for (var _i13 = 0; _i13 < _size8; ++_i13)
        {
          var elem14 = null;
          elem14 = new XcalarApiFileT();
          elem14.read(input);
          this.files.push(elem14);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiListFilesOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiListFilesOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.numFiles !== null && this.numFiles !== undefined) {
    output.writeFieldBegin('numFiles', Thrift.Type.I64, 2);
    output.writeI64(this.numFiles);
    output.writeFieldEnd();
  }
  if (this.files !== null && this.files !== undefined) {
    output.writeFieldBegin('files', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.files.length);
    for (var iter15 in this.files)
    {
      if (this.files.hasOwnProperty(iter15))
      {
        iter15 = this.files[iter15];
        iter15.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiTableT = function(args) {
  this.tableName = null;
  this.tableId = null;
  if (args) {
    if (args.tableName !== undefined) {
      this.tableName = args.tableName;
    }
    if (args.tableId !== undefined) {
      this.tableId = args.tableId;
    }
  }
};
XcalarApiTableT.prototype = {};
XcalarApiTableT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.tableName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.tableId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiTableT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiTableT');
  if (this.tableName !== null && this.tableName !== undefined) {
    output.writeFieldBegin('tableName', Thrift.Type.STRING, 1);
    output.writeString(this.tableName);
    output.writeFieldEnd();
  }
  if (this.tableId !== null && this.tableId !== undefined) {
    output.writeFieldBegin('tableId', Thrift.Type.I64, 2);
    output.writeI64(this.tableId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiDatasetT = function(args) {
  this.url = null;
  this.datasetId = null;
  this.formatType = null;
  this.name = null;
  this.loadIsComplete = null;
  this.refCount = null;
  if (args) {
    if (args.url !== undefined) {
      this.url = args.url;
    }
    if (args.datasetId !== undefined) {
      this.datasetId = args.datasetId;
    }
    if (args.formatType !== undefined) {
      this.formatType = args.formatType;
    }
    if (args.name !== undefined) {
      this.name = args.name;
    }
    if (args.loadIsComplete !== undefined) {
      this.loadIsComplete = args.loadIsComplete;
    }
    if (args.refCount !== undefined) {
      this.refCount = args.refCount;
    }
  }
};
XcalarApiDatasetT.prototype = {};
XcalarApiDatasetT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.url = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.datasetId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.formatType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.BOOL) {
        this.loadIsComplete = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.refCount = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiDatasetT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiDatasetT');
  if (this.url !== null && this.url !== undefined) {
    output.writeFieldBegin('url', Thrift.Type.STRING, 1);
    output.writeString(this.url);
    output.writeFieldEnd();
  }
  if (this.datasetId !== null && this.datasetId !== undefined) {
    output.writeFieldBegin('datasetId', Thrift.Type.I64, 2);
    output.writeI64(this.datasetId);
    output.writeFieldEnd();
  }
  if (this.formatType !== null && this.formatType !== undefined) {
    output.writeFieldBegin('formatType', Thrift.Type.I32, 3);
    output.writeI32(this.formatType);
    output.writeFieldEnd();
  }
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 4);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.loadIsComplete !== null && this.loadIsComplete !== undefined) {
    output.writeFieldBegin('loadIsComplete', Thrift.Type.BOOL, 5);
    output.writeBool(this.loadIsComplete);
    output.writeFieldEnd();
  }
  if (this.refCount !== null && this.refCount !== undefined) {
    output.writeFieldBegin('refCount', Thrift.Type.I32, 6);
    output.writeI32(this.refCount);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiDfCsvLoadArgsT = function(args) {
  this.recordDelim = null;
  this.fieldDelim = null;
  if (args) {
    if (args.recordDelim !== undefined) {
      this.recordDelim = args.recordDelim;
    }
    if (args.fieldDelim !== undefined) {
      this.fieldDelim = args.fieldDelim;
    }
  }
};
XcalarApiDfCsvLoadArgsT.prototype = {};
XcalarApiDfCsvLoadArgsT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.recordDelim = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.fieldDelim = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiDfCsvLoadArgsT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiDfCsvLoadArgsT');
  if (this.recordDelim !== null && this.recordDelim !== undefined) {
    output.writeFieldBegin('recordDelim', Thrift.Type.STRING, 1);
    output.writeString(this.recordDelim);
    output.writeFieldEnd();
  }
  if (this.fieldDelim !== null && this.fieldDelim !== undefined) {
    output.writeFieldBegin('fieldDelim', Thrift.Type.STRING, 2);
    output.writeString(this.fieldDelim);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiDfLoadArgsT = function(args) {
  this.csv = null;
  if (args) {
    if (args.csv !== undefined) {
      this.csv = args.csv;
    }
  }
};
XcalarApiDfLoadArgsT.prototype = {};
XcalarApiDfLoadArgsT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.csv = new XcalarApiDfCsvLoadArgsT();
        this.csv.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiDfLoadArgsT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiDfLoadArgsT');
  if (this.csv !== null && this.csv !== undefined) {
    output.writeFieldBegin('csv', Thrift.Type.STRUCT, 1);
    this.csv.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiExportInputT = function(args) {
  this.srcTable = null;
  this.fileName = null;
  if (args) {
    if (args.srcTable !== undefined) {
      this.srcTable = args.srcTable;
    }
    if (args.fileName !== undefined) {
      this.fileName = args.fileName;
    }
  }
};
XcalarApiExportInputT.prototype = {};
XcalarApiExportInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.srcTable = new XcalarApiTableT();
        this.srcTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.fileName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiExportInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiExportInputT');
  if (this.srcTable !== null && this.srcTable !== undefined) {
    output.writeFieldBegin('srcTable', Thrift.Type.STRUCT, 1);
    this.srcTable.write(output);
    output.writeFieldEnd();
  }
  if (this.fileName !== null && this.fileName !== undefined) {
    output.writeFieldBegin('fileName', Thrift.Type.STRING, 2);
    output.writeString(this.fileName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiExportOutputT = function(args) {
  this.status = null;
  this.outputPath = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.outputPath !== undefined) {
      this.outputPath = args.outputPath;
    }
  }
};
XcalarApiExportOutputT.prototype = {};
XcalarApiExportOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.outputPath = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiExportOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiExportOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.outputPath !== null && this.outputPath !== undefined) {
    output.writeFieldBegin('outputPath', Thrift.Type.STRING, 2);
    output.writeString(this.outputPath);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiBulkLoadInputT = function(args) {
  this.dataset = null;
  this.maxSize = null;
  this.loadArgs = null;
  if (args) {
    if (args.dataset !== undefined) {
      this.dataset = args.dataset;
    }
    if (args.maxSize !== undefined) {
      this.maxSize = args.maxSize;
    }
    if (args.loadArgs !== undefined) {
      this.loadArgs = args.loadArgs;
    }
  }
};
XcalarApiBulkLoadInputT.prototype = {};
XcalarApiBulkLoadInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.dataset = new XcalarApiDatasetT();
        this.dataset.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.maxSize = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.loadArgs = new XcalarApiDfLoadArgsT();
        this.loadArgs.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiBulkLoadInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiBulkLoadInputT');
  if (this.dataset !== null && this.dataset !== undefined) {
    output.writeFieldBegin('dataset', Thrift.Type.STRUCT, 1);
    this.dataset.write(output);
    output.writeFieldEnd();
  }
  if (this.maxSize !== null && this.maxSize !== undefined) {
    output.writeFieldBegin('maxSize', Thrift.Type.I64, 2);
    output.writeI64(this.maxSize);
    output.writeFieldEnd();
  }
  if (this.loadArgs !== null && this.loadArgs !== undefined) {
    output.writeFieldBegin('loadArgs', Thrift.Type.STRUCT, 3);
    this.loadArgs.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiNamedInputT = function(args) {
  this.isTable = null;
  this.name = null;
  this.xid = null;
  if (args) {
    if (args.isTable !== undefined) {
      this.isTable = args.isTable;
    }
    if (args.name !== undefined) {
      this.name = args.name;
    }
    if (args.xid !== undefined) {
      this.xid = args.xid;
    }
  }
};
XcalarApiNamedInputT.prototype = {};
XcalarApiNamedInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.isTable = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.xid = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiNamedInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiNamedInputT');
  if (this.isTable !== null && this.isTable !== undefined) {
    output.writeFieldBegin('isTable', Thrift.Type.BOOL, 1);
    output.writeBool(this.isTable);
    output.writeFieldEnd();
  }
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 2);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.xid !== null && this.xid !== undefined) {
    output.writeFieldBegin('xid', Thrift.Type.I64, 3);
    output.writeI64(this.xid);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiIndexInputT = function(args) {
  this.source = null;
  this.keyName = null;
  this.dstTable = null;
  if (args) {
    if (args.source !== undefined) {
      this.source = args.source;
    }
    if (args.keyName !== undefined) {
      this.keyName = args.keyName;
    }
    if (args.dstTable !== undefined) {
      this.dstTable = args.dstTable;
    }
  }
};
XcalarApiIndexInputT.prototype = {};
XcalarApiIndexInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.source = new XcalarApiNamedInputT();
        this.source.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.keyName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.dstTable = new XcalarApiTableT();
        this.dstTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiIndexInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiIndexInputT');
  if (this.source !== null && this.source !== undefined) {
    output.writeFieldBegin('source', Thrift.Type.STRUCT, 1);
    this.source.write(output);
    output.writeFieldEnd();
  }
  if (this.keyName !== null && this.keyName !== undefined) {
    output.writeFieldBegin('keyName', Thrift.Type.STRING, 2);
    output.writeString(this.keyName);
    output.writeFieldEnd();
  }
  if (this.dstTable !== null && this.dstTable !== undefined) {
    output.writeFieldBegin('dstTable', Thrift.Type.STRUCT, 3);
    this.dstTable.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiStatInputT = function(args) {
  this.nodeId = null;
  if (args) {
    if (args.nodeId !== undefined) {
      this.nodeId = args.nodeId;
    }
  }
};
XcalarApiStatInputT.prototype = {};
XcalarApiStatInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.nodeId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiStatInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiStatInputT');
  if (this.nodeId !== null && this.nodeId !== undefined) {
    output.writeFieldBegin('nodeId', Thrift.Type.I64, 1);
    output.writeI64(this.nodeId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiMakeRetinaInputT = function(args) {
  this.retinaName = null;
  this.tableName = null;
  if (args) {
    if (args.retinaName !== undefined) {
      this.retinaName = args.retinaName;
    }
    if (args.tableName !== undefined) {
      this.tableName = args.tableName;
    }
  }
};
XcalarApiMakeRetinaInputT.prototype = {};
XcalarApiMakeRetinaInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.retinaName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.tableName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiMakeRetinaInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiMakeRetinaInputT');
  if (this.retinaName !== null && this.retinaName !== undefined) {
    output.writeFieldBegin('retinaName', Thrift.Type.STRING, 1);
    output.writeString(this.retinaName);
    output.writeFieldEnd();
  }
  if (this.tableName !== null && this.tableName !== undefined) {
    output.writeFieldBegin('tableName', Thrift.Type.STRING, 2);
    output.writeString(this.tableName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiFilterInputT = function(args) {
  this.filterStr = null;
  this.srcTable = null;
  this.dstTable = null;
  if (args) {
    if (args.filterStr !== undefined) {
      this.filterStr = args.filterStr;
    }
    if (args.srcTable !== undefined) {
      this.srcTable = args.srcTable;
    }
    if (args.dstTable !== undefined) {
      this.dstTable = args.dstTable;
    }
  }
};
XcalarApiFilterInputT.prototype = {};
XcalarApiFilterInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.filterStr = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.srcTable = new XcalarApiTableT();
        this.srcTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.dstTable = new XcalarApiTableT();
        this.dstTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiFilterInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiFilterInputT');
  if (this.filterStr !== null && this.filterStr !== undefined) {
    output.writeFieldBegin('filterStr', Thrift.Type.STRING, 1);
    output.writeString(this.filterStr);
    output.writeFieldEnd();
  }
  if (this.srcTable !== null && this.srcTable !== undefined) {
    output.writeFieldBegin('srcTable', Thrift.Type.STRUCT, 2);
    this.srcTable.write(output);
    output.writeFieldEnd();
  }
  if (this.dstTable !== null && this.dstTable !== undefined) {
    output.writeFieldBegin('dstTable', Thrift.Type.STRUCT, 3);
    this.dstTable.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiGroupByInputT = function(args) {
  this.table = null;
  this.groupByTable = null;
  this.groupByOp = null;
  this.fieldName = null;
  this.newFieldName = null;
  if (args) {
    if (args.table !== undefined) {
      this.table = args.table;
    }
    if (args.groupByTable !== undefined) {
      this.groupByTable = args.groupByTable;
    }
    if (args.groupByOp !== undefined) {
      this.groupByOp = args.groupByOp;
    }
    if (args.fieldName !== undefined) {
      this.fieldName = args.fieldName;
    }
    if (args.newFieldName !== undefined) {
      this.newFieldName = args.newFieldName;
    }
  }
};
XcalarApiGroupByInputT.prototype = {};
XcalarApiGroupByInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.table = new XcalarApiTableT();
        this.table.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.groupByTable = new XcalarApiTableT();
        this.groupByTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.groupByOp = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.fieldName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.newFieldName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiGroupByInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiGroupByInputT');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRUCT, 1);
    this.table.write(output);
    output.writeFieldEnd();
  }
  if (this.groupByTable !== null && this.groupByTable !== undefined) {
    output.writeFieldBegin('groupByTable', Thrift.Type.STRUCT, 2);
    this.groupByTable.write(output);
    output.writeFieldEnd();
  }
  if (this.groupByOp !== null && this.groupByOp !== undefined) {
    output.writeFieldBegin('groupByOp', Thrift.Type.I32, 3);
    output.writeI32(this.groupByOp);
    output.writeFieldEnd();
  }
  if (this.fieldName !== null && this.fieldName !== undefined) {
    output.writeFieldBegin('fieldName', Thrift.Type.STRING, 4);
    output.writeString(this.fieldName);
    output.writeFieldEnd();
  }
  if (this.newFieldName !== null && this.newFieldName !== undefined) {
    output.writeFieldBegin('newFieldName', Thrift.Type.STRING, 5);
    output.writeString(this.newFieldName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiAggregateInputT = function(args) {
  this.table = null;
  this.aggregateOp = null;
  this.fieldName = null;
  if (args) {
    if (args.table !== undefined) {
      this.table = args.table;
    }
    if (args.aggregateOp !== undefined) {
      this.aggregateOp = args.aggregateOp;
    }
    if (args.fieldName !== undefined) {
      this.fieldName = args.fieldName;
    }
  }
};
XcalarApiAggregateInputT.prototype = {};
XcalarApiAggregateInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.table = new XcalarApiTableT();
        this.table.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.aggregateOp = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.fieldName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiAggregateInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiAggregateInputT');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRUCT, 1);
    this.table.write(output);
    output.writeFieldEnd();
  }
  if (this.aggregateOp !== null && this.aggregateOp !== undefined) {
    output.writeFieldBegin('aggregateOp', Thrift.Type.I32, 2);
    output.writeI32(this.aggregateOp);
    output.writeFieldEnd();
  }
  if (this.fieldName !== null && this.fieldName !== undefined) {
    output.writeFieldBegin('fieldName', Thrift.Type.STRING, 3);
    output.writeString(this.fieldName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiEditColInputT = function(args) {
  this.source = null;
  this.currFieldName = null;
  this.newFieldName = null;
  this.newFieldType = null;
  if (args) {
    if (args.source !== undefined) {
      this.source = args.source;
    }
    if (args.currFieldName !== undefined) {
      this.currFieldName = args.currFieldName;
    }
    if (args.newFieldName !== undefined) {
      this.newFieldName = args.newFieldName;
    }
    if (args.newFieldType !== undefined) {
      this.newFieldType = args.newFieldType;
    }
  }
};
XcalarApiEditColInputT.prototype = {};
XcalarApiEditColInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.source = new XcalarApiNamedInputT();
        this.source.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.currFieldName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.newFieldName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.newFieldType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiEditColInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiEditColInputT');
  if (this.source !== null && this.source !== undefined) {
    output.writeFieldBegin('source', Thrift.Type.STRUCT, 1);
    this.source.write(output);
    output.writeFieldEnd();
  }
  if (this.currFieldName !== null && this.currFieldName !== undefined) {
    output.writeFieldBegin('currFieldName', Thrift.Type.STRING, 2);
    output.writeString(this.currFieldName);
    output.writeFieldEnd();
  }
  if (this.newFieldName !== null && this.newFieldName !== undefined) {
    output.writeFieldBegin('newFieldName', Thrift.Type.STRING, 3);
    output.writeString(this.newFieldName);
    output.writeFieldEnd();
  }
  if (this.newFieldType !== null && this.newFieldType !== undefined) {
    output.writeFieldBegin('newFieldType', Thrift.Type.I32, 4);
    output.writeI32(this.newFieldType);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiResultSetNextInputT = function(args) {
  this.resultSetId = null;
  this.numRecords = null;
  if (args) {
    if (args.resultSetId !== undefined) {
      this.resultSetId = args.resultSetId;
    }
    if (args.numRecords !== undefined) {
      this.numRecords = args.numRecords;
    }
  }
};
XcalarApiResultSetNextInputT.prototype = {};
XcalarApiResultSetNextInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.resultSetId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numRecords = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiResultSetNextInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiResultSetNextInputT');
  if (this.resultSetId !== null && this.resultSetId !== undefined) {
    output.writeFieldBegin('resultSetId', Thrift.Type.I64, 1);
    output.writeI64(this.resultSetId);
    output.writeFieldEnd();
  }
  if (this.numRecords !== null && this.numRecords !== undefined) {
    output.writeFieldBegin('numRecords', Thrift.Type.I64, 2);
    output.writeI64(this.numRecords);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiFreeResultSetInputT = function(args) {
  this.resultSetId = null;
  if (args) {
    if (args.resultSetId !== undefined) {
      this.resultSetId = args.resultSetId;
    }
  }
};
XcalarApiFreeResultSetInputT.prototype = {};
XcalarApiFreeResultSetInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.resultSetId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiFreeResultSetInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiFreeResultSetInputT');
  if (this.resultSetId !== null && this.resultSetId !== undefined) {
    output.writeFieldBegin('resultSetId', Thrift.Type.I64, 1);
    output.writeI64(this.resultSetId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiStatT = function(args) {
  this.threadName = null;
  this.statName = null;
  this.statValue = null;
  this.statType = null;
  this.statLife = null;
  this.groupId = null;
  if (args) {
    if (args.threadName !== undefined) {
      this.threadName = args.threadName;
    }
    if (args.statName !== undefined) {
      this.statName = args.statName;
    }
    if (args.statValue !== undefined) {
      this.statValue = args.statValue;
    }
    if (args.statType !== undefined) {
      this.statType = args.statType;
    }
    if (args.statLife !== undefined) {
      this.statLife = args.statLife;
    }
    if (args.groupId !== undefined) {
      this.groupId = args.groupId;
    }
  }
};
XcalarApiStatT.prototype = {};
XcalarApiStatT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.threadName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.statName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.statValue = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.statType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.statLife = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.groupId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiStatT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiStatT');
  if (this.threadName !== null && this.threadName !== undefined) {
    output.writeFieldBegin('threadName', Thrift.Type.STRING, 1);
    output.writeString(this.threadName);
    output.writeFieldEnd();
  }
  if (this.statName !== null && this.statName !== undefined) {
    output.writeFieldBegin('statName', Thrift.Type.STRING, 2);
    output.writeString(this.statName);
    output.writeFieldEnd();
  }
  if (this.statValue !== null && this.statValue !== undefined) {
    output.writeFieldBegin('statValue', Thrift.Type.I64, 3);
    output.writeI64(this.statValue);
    output.writeFieldEnd();
  }
  if (this.statType !== null && this.statType !== undefined) {
    output.writeFieldBegin('statType', Thrift.Type.I32, 4);
    output.writeI32(this.statType);
    output.writeFieldEnd();
  }
  if (this.statLife !== null && this.statLife !== undefined) {
    output.writeFieldBegin('statLife', Thrift.Type.I32, 5);
    output.writeI32(this.statLife);
    output.writeFieldEnd();
  }
  if (this.groupId !== null && this.groupId !== undefined) {
    output.writeFieldBegin('groupId', Thrift.Type.I64, 6);
    output.writeI64(this.groupId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiJoinInputT = function(args) {
  this.leftTable = null;
  this.rightTable = null;
  this.joinTable = null;
  this.joinType = null;
  if (args) {
    if (args.leftTable !== undefined) {
      this.leftTable = args.leftTable;
    }
    if (args.rightTable !== undefined) {
      this.rightTable = args.rightTable;
    }
    if (args.joinTable !== undefined) {
      this.joinTable = args.joinTable;
    }
    if (args.joinType !== undefined) {
      this.joinType = args.joinType;
    }
  }
};
XcalarApiJoinInputT.prototype = {};
XcalarApiJoinInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.leftTable = new XcalarApiTableT();
        this.leftTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.rightTable = new XcalarApiTableT();
        this.rightTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.joinTable = new XcalarApiTableT();
        this.joinTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.joinType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiJoinInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiJoinInputT');
  if (this.leftTable !== null && this.leftTable !== undefined) {
    output.writeFieldBegin('leftTable', Thrift.Type.STRUCT, 1);
    this.leftTable.write(output);
    output.writeFieldEnd();
  }
  if (this.rightTable !== null && this.rightTable !== undefined) {
    output.writeFieldBegin('rightTable', Thrift.Type.STRUCT, 2);
    this.rightTable.write(output);
    output.writeFieldEnd();
  }
  if (this.joinTable !== null && this.joinTable !== undefined) {
    output.writeFieldBegin('joinTable', Thrift.Type.STRUCT, 3);
    this.joinTable.write(output);
    output.writeFieldEnd();
  }
  if (this.joinType !== null && this.joinType !== undefined) {
    output.writeFieldBegin('joinType', Thrift.Type.I32, 4);
    output.writeI32(this.joinType);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiResultSetAbsoluteInputT = function(args) {
  this.resultSetId = null;
  this.position = null;
  if (args) {
    if (args.resultSetId !== undefined) {
      this.resultSetId = args.resultSetId;
    }
    if (args.position !== undefined) {
      this.position = args.position;
    }
  }
};
XcalarApiResultSetAbsoluteInputT.prototype = {};
XcalarApiResultSetAbsoluteInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.resultSetId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.position = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiResultSetAbsoluteInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiResultSetAbsoluteInputT');
  if (this.resultSetId !== null && this.resultSetId !== undefined) {
    output.writeFieldBegin('resultSetId', Thrift.Type.I64, 1);
    output.writeI64(this.resultSetId);
    output.writeFieldEnd();
  }
  if (this.position !== null && this.position !== undefined) {
    output.writeFieldBegin('position', Thrift.Type.I64, 2);
    output.writeI64(this.position);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiParameterT = function(args) {
  this.parameterName = null;
  this.parameterValue = null;
  if (args) {
    if (args.parameterName !== undefined) {
      this.parameterName = args.parameterName;
    }
    if (args.parameterValue !== undefined) {
      this.parameterValue = args.parameterValue;
    }
  }
};
XcalarApiParameterT.prototype = {};
XcalarApiParameterT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.parameterName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.parameterValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiParameterT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiParameterT');
  if (this.parameterName !== null && this.parameterName !== undefined) {
    output.writeFieldBegin('parameterName', Thrift.Type.STRING, 1);
    output.writeString(this.parameterName);
    output.writeFieldEnd();
  }
  if (this.parameterValue !== null && this.parameterValue !== undefined) {
    output.writeFieldBegin('parameterValue', Thrift.Type.STRING, 2);
    output.writeString(this.parameterValue);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiParamLoadT = function(args) {
  this.datasetUrl = null;
  if (args) {
    if (args.datasetUrl !== undefined) {
      this.datasetUrl = args.datasetUrl;
    }
  }
};
XcalarApiParamLoadT.prototype = {};
XcalarApiParamLoadT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.datasetUrl = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiParamLoadT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiParamLoadT');
  if (this.datasetUrl !== null && this.datasetUrl !== undefined) {
    output.writeFieldBegin('datasetUrl', Thrift.Type.STRING, 1);
    output.writeString(this.datasetUrl);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiParamFilterT = function(args) {
  this.filterStr = null;
  if (args) {
    if (args.filterStr !== undefined) {
      this.filterStr = args.filterStr;
    }
  }
};
XcalarApiParamFilterT.prototype = {};
XcalarApiParamFilterT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.filterStr = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiParamFilterT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiParamFilterT');
  if (this.filterStr !== null && this.filterStr !== undefined) {
    output.writeFieldBegin('filterStr', Thrift.Type.STRING, 1);
    output.writeString(this.filterStr);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiParamInputT = function(args) {
  this.paramLoad = null;
  this.paramFilter = null;
  if (args) {
    if (args.paramLoad !== undefined) {
      this.paramLoad = args.paramLoad;
    }
    if (args.paramFilter !== undefined) {
      this.paramFilter = args.paramFilter;
    }
  }
};
XcalarApiParamInputT.prototype = {};
XcalarApiParamInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.paramLoad = new XcalarApiParamLoadT();
        this.paramLoad.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.paramFilter = new XcalarApiParamFilterT();
        this.paramFilter.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiParamInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiParamInputT');
  if (this.paramLoad !== null && this.paramLoad !== undefined) {
    output.writeFieldBegin('paramLoad', Thrift.Type.STRUCT, 1);
    this.paramLoad.write(output);
    output.writeFieldEnd();
  }
  if (this.paramFilter !== null && this.paramFilter !== undefined) {
    output.writeFieldBegin('paramFilter', Thrift.Type.STRUCT, 2);
    this.paramFilter.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiUpdateRetinaInputT = function(args) {
  this.retinaName = null;
  this.dagNodeId = null;
  this.paramType = null;
  this.paramInput = null;
  if (args) {
    if (args.retinaName !== undefined) {
      this.retinaName = args.retinaName;
    }
    if (args.dagNodeId !== undefined) {
      this.dagNodeId = args.dagNodeId;
    }
    if (args.paramType !== undefined) {
      this.paramType = args.paramType;
    }
    if (args.paramInput !== undefined) {
      this.paramInput = args.paramInput;
    }
  }
};
XcalarApiUpdateRetinaInputT.prototype = {};
XcalarApiUpdateRetinaInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.retinaName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.dagNodeId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.paramType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.paramInput = new XcalarApiParamInputT();
        this.paramInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiUpdateRetinaInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiUpdateRetinaInputT');
  if (this.retinaName !== null && this.retinaName !== undefined) {
    output.writeFieldBegin('retinaName', Thrift.Type.STRING, 1);
    output.writeString(this.retinaName);
    output.writeFieldEnd();
  }
  if (this.dagNodeId !== null && this.dagNodeId !== undefined) {
    output.writeFieldBegin('dagNodeId', Thrift.Type.I64, 2);
    output.writeI64(this.dagNodeId);
    output.writeFieldEnd();
  }
  if (this.paramType !== null && this.paramType !== undefined) {
    output.writeFieldBegin('paramType', Thrift.Type.I32, 3);
    output.writeI32(this.paramType);
    output.writeFieldEnd();
  }
  if (this.paramInput !== null && this.paramInput !== undefined) {
    output.writeFieldBegin('paramInput', Thrift.Type.STRUCT, 4);
    this.paramInput.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiAddParameterToRetinaInputT = function(args) {
  this.retinaName = null;
  this.parameter = null;
  if (args) {
    if (args.retinaName !== undefined) {
      this.retinaName = args.retinaName;
    }
    if (args.parameter !== undefined) {
      this.parameter = args.parameter;
    }
  }
};
XcalarApiAddParameterToRetinaInputT.prototype = {};
XcalarApiAddParameterToRetinaInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.retinaName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.parameter = new XcalarApiParameterT();
        this.parameter.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiAddParameterToRetinaInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiAddParameterToRetinaInputT');
  if (this.retinaName !== null && this.retinaName !== undefined) {
    output.writeFieldBegin('retinaName', Thrift.Type.STRING, 1);
    output.writeString(this.retinaName);
    output.writeFieldEnd();
  }
  if (this.parameter !== null && this.parameter !== undefined) {
    output.writeFieldBegin('parameter', Thrift.Type.STRUCT, 2);
    this.parameter.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiListParametersInRetinaOutputT = function(args) {
  this.status = null;
  this.numParameters = null;
  this.parameters = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.numParameters !== undefined) {
      this.numParameters = args.numParameters;
    }
    if (args.parameters !== undefined) {
      this.parameters = args.parameters;
    }
  }
};
XcalarApiListParametersInRetinaOutputT.prototype = {};
XcalarApiListParametersInRetinaOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numParameters = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size16 = 0;
        var _rtmp320;
        this.parameters = [];
        var _etype19 = 0;
        _rtmp320 = input.readListBegin();
        _etype19 = _rtmp320.etype;
        _size16 = _rtmp320.size;
        for (var _i21 = 0; _i21 < _size16; ++_i21)
        {
          var elem22 = null;
          elem22 = new XcalarApiParameterT();
          elem22.read(input);
          this.parameters.push(elem22);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiListParametersInRetinaOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiListParametersInRetinaOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.numParameters !== null && this.numParameters !== undefined) {
    output.writeFieldBegin('numParameters', Thrift.Type.I64, 2);
    output.writeI64(this.numParameters);
    output.writeFieldEnd();
  }
  if (this.parameters !== null && this.parameters !== undefined) {
    output.writeFieldBegin('parameters', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.parameters.length);
    for (var iter23 in this.parameters)
    {
      if (this.parameters.hasOwnProperty(iter23))
      {
        iter23 = this.parameters[iter23];
        iter23.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiExecuteRetinaInputT = function(args) {
  this.retinaName = null;
  this.exportToFile = null;
  this.dstTableName = null;
  this.exportFileName = null;
  this.numParameters = null;
  this.parameters = null;
  if (args) {
    if (args.retinaName !== undefined) {
      this.retinaName = args.retinaName;
    }
    if (args.exportToFile !== undefined) {
      this.exportToFile = args.exportToFile;
    }
    if (args.dstTableName !== undefined) {
      this.dstTableName = args.dstTableName;
    }
    if (args.exportFileName !== undefined) {
      this.exportFileName = args.exportFileName;
    }
    if (args.numParameters !== undefined) {
      this.numParameters = args.numParameters;
    }
    if (args.parameters !== undefined) {
      this.parameters = args.parameters;
    }
  }
};
XcalarApiExecuteRetinaInputT.prototype = {};
XcalarApiExecuteRetinaInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.retinaName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.exportToFile = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.dstTableName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.exportFileName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.numParameters = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.LIST) {
        var _size24 = 0;
        var _rtmp328;
        this.parameters = [];
        var _etype27 = 0;
        _rtmp328 = input.readListBegin();
        _etype27 = _rtmp328.etype;
        _size24 = _rtmp328.size;
        for (var _i29 = 0; _i29 < _size24; ++_i29)
        {
          var elem30 = null;
          elem30 = new XcalarApiParameterT();
          elem30.read(input);
          this.parameters.push(elem30);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiExecuteRetinaInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiExecuteRetinaInputT');
  if (this.retinaName !== null && this.retinaName !== undefined) {
    output.writeFieldBegin('retinaName', Thrift.Type.STRING, 1);
    output.writeString(this.retinaName);
    output.writeFieldEnd();
  }
  if (this.exportToFile !== null && this.exportToFile !== undefined) {
    output.writeFieldBegin('exportToFile', Thrift.Type.BOOL, 2);
    output.writeBool(this.exportToFile);
    output.writeFieldEnd();
  }
  if (this.dstTableName !== null && this.dstTableName !== undefined) {
    output.writeFieldBegin('dstTableName', Thrift.Type.STRING, 3);
    output.writeString(this.dstTableName);
    output.writeFieldEnd();
  }
  if (this.exportFileName !== null && this.exportFileName !== undefined) {
    output.writeFieldBegin('exportFileName', Thrift.Type.STRING, 4);
    output.writeString(this.exportFileName);
    output.writeFieldEnd();
  }
  if (this.numParameters !== null && this.numParameters !== undefined) {
    output.writeFieldBegin('numParameters', Thrift.Type.I64, 5);
    output.writeI64(this.numParameters);
    output.writeFieldEnd();
  }
  if (this.parameters !== null && this.parameters !== undefined) {
    output.writeFieldBegin('parameters', Thrift.Type.LIST, 6);
    output.writeListBegin(Thrift.Type.STRUCT, this.parameters.length);
    for (var iter31 in this.parameters)
    {
      if (this.parameters.hasOwnProperty(iter31))
      {
        iter31 = this.parameters[iter31];
        iter31.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiGetStatOutputT = function(args) {
  this.status = null;
  this.numStats = null;
  this.stats = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.numStats !== undefined) {
      this.numStats = args.numStats;
    }
    if (args.stats !== undefined) {
      this.stats = args.stats;
    }
  }
};
XcalarApiGetStatOutputT.prototype = {};
XcalarApiGetStatOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numStats = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size32 = 0;
        var _rtmp336;
        this.stats = [];
        var _etype35 = 0;
        _rtmp336 = input.readListBegin();
        _etype35 = _rtmp336.etype;
        _size32 = _rtmp336.size;
        for (var _i37 = 0; _i37 < _size32; ++_i37)
        {
          var elem38 = null;
          elem38 = new XcalarApiStatT();
          elem38.read(input);
          this.stats.push(elem38);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiGetStatOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiGetStatOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.numStats !== null && this.numStats !== undefined) {
    output.writeFieldBegin('numStats', Thrift.Type.I64, 2);
    output.writeI64(this.numStats);
    output.writeFieldEnd();
  }
  if (this.stats !== null && this.stats !== undefined) {
    output.writeFieldBegin('stats', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.stats.length);
    for (var iter39 in this.stats)
    {
      if (this.stats.hasOwnProperty(iter39))
      {
        iter39 = this.stats[iter39];
        iter39.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiStatByGroupIdInputT = function(args) {
  this.nodeId = null;
  this.numGroupId = null;
  this.groupId = null;
  if (args) {
    if (args.nodeId !== undefined) {
      this.nodeId = args.nodeId;
    }
    if (args.numGroupId !== undefined) {
      this.numGroupId = args.numGroupId;
    }
    if (args.groupId !== undefined) {
      this.groupId = args.groupId;
    }
  }
};
XcalarApiStatByGroupIdInputT.prototype = {};
XcalarApiStatByGroupIdInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.nodeId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numGroupId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size40 = 0;
        var _rtmp344;
        this.groupId = [];
        var _etype43 = 0;
        _rtmp344 = input.readListBegin();
        _etype43 = _rtmp344.etype;
        _size40 = _rtmp344.size;
        for (var _i45 = 0; _i45 < _size40; ++_i45)
        {
          var elem46 = null;
          elem46 = input.readI64().value;
          this.groupId.push(elem46);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiStatByGroupIdInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiStatByGroupIdInputT');
  if (this.nodeId !== null && this.nodeId !== undefined) {
    output.writeFieldBegin('nodeId', Thrift.Type.I64, 1);
    output.writeI64(this.nodeId);
    output.writeFieldEnd();
  }
  if (this.numGroupId !== null && this.numGroupId !== undefined) {
    output.writeFieldBegin('numGroupId', Thrift.Type.I64, 2);
    output.writeI64(this.numGroupId);
    output.writeFieldEnd();
  }
  if (this.groupId !== null && this.groupId !== undefined) {
    output.writeFieldBegin('groupId', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.I64, this.groupId.length);
    for (var iter47 in this.groupId)
    {
      if (this.groupId.hasOwnProperty(iter47))
      {
        iter47 = this.groupId[iter47];
        output.writeI64(iter47);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiMapInputT = function(args) {
  this.evalStr = null;
  this.srcTable = null;
  this.dstTable = null;
  this.newFieldName = null;
  if (args) {
    if (args.evalStr !== undefined) {
      this.evalStr = args.evalStr;
    }
    if (args.srcTable !== undefined) {
      this.srcTable = args.srcTable;
    }
    if (args.dstTable !== undefined) {
      this.dstTable = args.dstTable;
    }
    if (args.newFieldName !== undefined) {
      this.newFieldName = args.newFieldName;
    }
  }
};
XcalarApiMapInputT.prototype = {};
XcalarApiMapInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.evalStr = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.srcTable = new XcalarApiTableT();
        this.srcTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.dstTable = new XcalarApiTableT();
        this.dstTable.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.newFieldName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiMapInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiMapInputT');
  if (this.evalStr !== null && this.evalStr !== undefined) {
    output.writeFieldBegin('evalStr', Thrift.Type.STRING, 1);
    output.writeString(this.evalStr);
    output.writeFieldEnd();
  }
  if (this.srcTable !== null && this.srcTable !== undefined) {
    output.writeFieldBegin('srcTable', Thrift.Type.STRUCT, 2);
    this.srcTable.write(output);
    output.writeFieldEnd();
  }
  if (this.dstTable !== null && this.dstTable !== undefined) {
    output.writeFieldBegin('dstTable', Thrift.Type.STRUCT, 3);
    this.dstTable.write(output);
    output.writeFieldEnd();
  }
  if (this.newFieldName !== null && this.newFieldName !== undefined) {
    output.writeFieldBegin('newFieldName', Thrift.Type.STRING, 4);
    output.writeString(this.newFieldName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiQueryStateInputT = function(args) {
  this.queryId = null;
  if (args) {
    if (args.queryId !== undefined) {
      this.queryId = args.queryId;
    }
  }
};
XcalarApiQueryStateInputT.prototype = {};
XcalarApiQueryStateInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.queryId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiQueryStateInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiQueryStateInputT');
  if (this.queryId !== null && this.queryId !== undefined) {
    output.writeFieldBegin('queryId', Thrift.Type.I64, 1);
    output.writeI64(this.queryId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiStartNodesInputT = function(args) {
  this.numNodes = null;
  if (args) {
    if (args.numNodes !== undefined) {
      this.numNodes = args.numNodes;
    }
  }
};
XcalarApiStartNodesInputT.prototype = {};
XcalarApiStartNodesInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.numNodes = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiStartNodesInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiStartNodesInputT');
  if (this.numNodes !== null && this.numNodes !== undefined) {
    output.writeFieldBegin('numNodes', Thrift.Type.I64, 1);
    output.writeI64(this.numNodes);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiGetStatGroupIdMapOutputT = function(args) {
  this.status = null;
  this.numGroupNames = null;
  this.groupName = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.numGroupNames !== undefined) {
      this.numGroupNames = args.numGroupNames;
    }
    if (args.groupName !== undefined) {
      this.groupName = args.groupName;
    }
  }
};
XcalarApiGetStatGroupIdMapOutputT.prototype = {};
XcalarApiGetStatGroupIdMapOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numGroupNames = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size48 = 0;
        var _rtmp352;
        this.groupName = [];
        var _etype51 = 0;
        _rtmp352 = input.readListBegin();
        _etype51 = _rtmp352.etype;
        _size48 = _rtmp352.size;
        for (var _i53 = 0; _i53 < _size48; ++_i53)
        {
          var elem54 = null;
          elem54 = input.readString().value;
          this.groupName.push(elem54);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiGetStatGroupIdMapOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiGetStatGroupIdMapOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.numGroupNames !== null && this.numGroupNames !== undefined) {
    output.writeFieldBegin('numGroupNames', Thrift.Type.I64, 2);
    output.writeI64(this.numGroupNames);
    output.writeFieldEnd();
  }
  if (this.groupName !== null && this.groupName !== undefined) {
    output.writeFieldBegin('groupName', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRING, this.groupName.length);
    for (var iter55 in this.groupName)
    {
      if (this.groupName.hasOwnProperty(iter55))
      {
        iter55 = this.groupName[iter55];
        output.writeString(iter55);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiCountOutputT = function(args) {
  this.status = null;
  this.numCounts = null;
  this.counts = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.numCounts !== undefined) {
      this.numCounts = args.numCounts;
    }
    if (args.counts !== undefined) {
      this.counts = args.counts;
    }
  }
};
XcalarApiCountOutputT.prototype = {};
XcalarApiCountOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numCounts = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size56 = 0;
        var _rtmp360;
        this.counts = [];
        var _etype59 = 0;
        _rtmp360 = input.readListBegin();
        _etype59 = _rtmp360.etype;
        _size56 = _rtmp360.size;
        for (var _i61 = 0; _i61 < _size56; ++_i61)
        {
          var elem62 = null;
          elem62 = input.readI64().value;
          this.counts.push(elem62);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiCountOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiCountOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.numCounts !== null && this.numCounts !== undefined) {
    output.writeFieldBegin('numCounts', Thrift.Type.I64, 2);
    output.writeI64(this.numCounts);
    output.writeFieldEnd();
  }
  if (this.counts !== null && this.counts !== undefined) {
    output.writeFieldBegin('counts', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.I64, this.counts.length);
    for (var iter63 in this.counts)
    {
      if (this.counts.hasOwnProperty(iter63))
      {
        iter63 = this.counts[iter63];
        output.writeI64(iter63);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiMakeResultSetOutputT = function(args) {
  this.status = null;
  this.resultSetId = null;
  this.numEntries = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.resultSetId !== undefined) {
      this.resultSetId = args.resultSetId;
    }
    if (args.numEntries !== undefined) {
      this.numEntries = args.numEntries;
    }
  }
};
XcalarApiMakeResultSetOutputT.prototype = {};
XcalarApiMakeResultSetOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.resultSetId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.numEntries = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiMakeResultSetOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiMakeResultSetOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.resultSetId !== null && this.resultSetId !== undefined) {
    output.writeFieldBegin('resultSetId', Thrift.Type.I64, 2);
    output.writeI64(this.resultSetId);
    output.writeFieldEnd();
  }
  if (this.numEntries !== null && this.numEntries !== undefined) {
    output.writeFieldBegin('numEntries', Thrift.Type.I64, 3);
    output.writeI64(this.numEntries);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiResultSetNextOutputT = function(args) {
  this.status = null;
  this.keysAttrHeader = null;
  this.kvPairs = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.keysAttrHeader !== undefined) {
      this.keysAttrHeader = args.keysAttrHeader;
    }
    if (args.kvPairs !== undefined) {
      this.kvPairs = args.kvPairs;
    }
  }
};
XcalarApiResultSetNextOutputT.prototype = {};
XcalarApiResultSetNextOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.keysAttrHeader = new DfFieldAttrHeaderT();
        this.keysAttrHeader.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.kvPairs = new KeyValuePairsT();
        this.kvPairs.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiResultSetNextOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiResultSetNextOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.keysAttrHeader !== null && this.keysAttrHeader !== undefined) {
    output.writeFieldBegin('keysAttrHeader', Thrift.Type.STRUCT, 2);
    this.keysAttrHeader.write(output);
    output.writeFieldEnd();
  }
  if (this.kvPairs !== null && this.kvPairs !== undefined) {
    output.writeFieldBegin('kvPairs', Thrift.Type.STRUCT, 3);
    this.kvPairs.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiListTablesOutputT = function(args) {
  this.numTables = null;
  this.tables = null;
  if (args) {
    if (args.numTables !== undefined) {
      this.numTables = args.numTables;
    }
    if (args.tables !== undefined) {
      this.tables = args.tables;
    }
  }
};
XcalarApiListTablesOutputT.prototype = {};
XcalarApiListTablesOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.numTables = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size64 = 0;
        var _rtmp368;
        this.tables = [];
        var _etype67 = 0;
        _rtmp368 = input.readListBegin();
        _etype67 = _rtmp368.etype;
        _size64 = _rtmp368.size;
        for (var _i69 = 0; _i69 < _size64; ++_i69)
        {
          var elem70 = null;
          elem70 = new XcalarApiTableT();
          elem70.read(input);
          this.tables.push(elem70);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiListTablesOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiListTablesOutputT');
  if (this.numTables !== null && this.numTables !== undefined) {
    output.writeFieldBegin('numTables', Thrift.Type.I64, 1);
    output.writeI64(this.numTables);
    output.writeFieldEnd();
  }
  if (this.tables !== null && this.tables !== undefined) {
    output.writeFieldBegin('tables', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.tables.length);
    for (var iter71 in this.tables)
    {
      if (this.tables.hasOwnProperty(iter71))
      {
        iter71 = this.tables[iter71];
        iter71.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiListDatasetsOutputT = function(args) {
  this.numDatasets = null;
  this.datasets = null;
  if (args) {
    if (args.numDatasets !== undefined) {
      this.numDatasets = args.numDatasets;
    }
    if (args.datasets !== undefined) {
      this.datasets = args.datasets;
    }
  }
};
XcalarApiListDatasetsOutputT.prototype = {};
XcalarApiListDatasetsOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.numDatasets = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size72 = 0;
        var _rtmp376;
        this.datasets = [];
        var _etype75 = 0;
        _rtmp376 = input.readListBegin();
        _etype75 = _rtmp376.etype;
        _size72 = _rtmp376.size;
        for (var _i77 = 0; _i77 < _size72; ++_i77)
        {
          var elem78 = null;
          elem78 = new XcalarApiDatasetT();
          elem78.read(input);
          this.datasets.push(elem78);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiListDatasetsOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiListDatasetsOutputT');
  if (this.numDatasets !== null && this.numDatasets !== undefined) {
    output.writeFieldBegin('numDatasets', Thrift.Type.I32, 1);
    output.writeI32(this.numDatasets);
    output.writeFieldEnd();
  }
  if (this.datasets !== null && this.datasets !== undefined) {
    output.writeFieldBegin('datasets', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.datasets.length);
    for (var iter79 in this.datasets)
    {
      if (this.datasets.hasOwnProperty(iter79))
      {
        iter79 = this.datasets[iter79];
        iter79.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiDeleteTableStatusT = function(args) {
  this.table = null;
  this.status = null;
  if (args) {
    if (args.table !== undefined) {
      this.table = args.table;
    }
    if (args.status !== undefined) {
      this.status = args.status;
    }
  }
};
XcalarApiDeleteTableStatusT.prototype = {};
XcalarApiDeleteTableStatusT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.table = new XcalarApiTableT();
        this.table.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiDeleteTableStatusT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiDeleteTableStatusT');
  if (this.table !== null && this.table !== undefined) {
    output.writeFieldBegin('table', Thrift.Type.STRUCT, 1);
    this.table.write(output);
    output.writeFieldEnd();
  }
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 2);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiBulkDeleteTablesOutputT = function(args) {
  this.numTables = null;
  this.status = null;
  this.statuses = null;
  if (args) {
    if (args.numTables !== undefined) {
      this.numTables = args.numTables;
    }
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.statuses !== undefined) {
      this.statuses = args.statuses;
    }
  }
};
XcalarApiBulkDeleteTablesOutputT.prototype = {};
XcalarApiBulkDeleteTablesOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.numTables = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size80 = 0;
        var _rtmp384;
        this.statuses = [];
        var _etype83 = 0;
        _rtmp384 = input.readListBegin();
        _etype83 = _rtmp384.etype;
        _size80 = _rtmp384.size;
        for (var _i85 = 0; _i85 < _size80; ++_i85)
        {
          var elem86 = null;
          elem86 = new XcalarApiDeleteTableStatusT();
          elem86.read(input);
          this.statuses.push(elem86);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiBulkDeleteTablesOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiBulkDeleteTablesOutputT');
  if (this.numTables !== null && this.numTables !== undefined) {
    output.writeFieldBegin('numTables', Thrift.Type.I32, 1);
    output.writeI32(this.numTables);
    output.writeFieldEnd();
  }
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 2);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.statuses !== null && this.statuses !== undefined) {
    output.writeFieldBegin('statuses', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.statuses.length);
    for (var iter87 in this.statuses)
    {
      if (this.statuses.hasOwnProperty(iter87))
      {
        iter87 = this.statuses[iter87];
        iter87.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiNewTableOutputT = function(args) {
  this.status = null;
  this.tableName = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.tableName !== undefined) {
      this.tableName = args.tableName;
    }
  }
};
XcalarApiNewTableOutputT.prototype = {};
XcalarApiNewTableOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.tableName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiNewTableOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiNewTableOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.tableName !== null && this.tableName !== undefined) {
    output.writeFieldBegin('tableName', Thrift.Type.STRING, 2);
    output.writeString(this.tableName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiGetTableRefCountOutputT = function(args) {
  this.status = null;
  this.refCount = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.refCount !== undefined) {
      this.refCount = args.refCount;
    }
  }
};
XcalarApiGetTableRefCountOutputT.prototype = {};
XcalarApiGetTableRefCountOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.refCount = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiGetTableRefCountOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiGetTableRefCountOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.refCount !== null && this.refCount !== undefined) {
    output.writeFieldBegin('refCount', Thrift.Type.I64, 2);
    output.writeI64(this.refCount);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiQueryOutputT = function(args) {
  this.status = null;
  this.queryId = null;
  this.nodeId = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.queryId !== undefined) {
      this.queryId = args.queryId;
    }
    if (args.nodeId !== undefined) {
      this.nodeId = args.nodeId;
    }
  }
};
XcalarApiQueryOutputT.prototype = {};
XcalarApiQueryOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.queryId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.nodeId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiQueryOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiQueryOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.queryId !== null && this.queryId !== undefined) {
    output.writeFieldBegin('queryId', Thrift.Type.I64, 2);
    output.writeI64(this.queryId);
    output.writeFieldEnd();
  }
  if (this.nodeId !== null && this.nodeId !== undefined) {
    output.writeFieldBegin('nodeId', Thrift.Type.I64, 3);
    output.writeI64(this.nodeId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiBulkLoadOutputT = function(args) {
  this.status = null;
  this.dataset = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.dataset !== undefined) {
      this.dataset = args.dataset;
    }
  }
};
XcalarApiBulkLoadOutputT.prototype = {};
XcalarApiBulkLoadOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.dataset = new XcalarApiDatasetT();
        this.dataset.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiBulkLoadOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiBulkLoadOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.dataset !== null && this.dataset !== undefined) {
    output.writeFieldBegin('dataset', Thrift.Type.STRUCT, 2);
    this.dataset.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiGetVersionOutputT = function(args) {
  this.version = null;
  this.apiVersionSignatureFull = null;
  this.apiVersionSignatureShort = null;
  if (args) {
    if (args.version !== undefined) {
      this.version = args.version;
    }
    if (args.apiVersionSignatureFull !== undefined) {
      this.apiVersionSignatureFull = args.apiVersionSignatureFull;
    }
    if (args.apiVersionSignatureShort !== undefined) {
      this.apiVersionSignatureShort = args.apiVersionSignatureShort;
    }
  }
};
XcalarApiGetVersionOutputT.prototype = {};
XcalarApiGetVersionOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.version = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.apiVersionSignatureFull = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.apiVersionSignatureShort = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiGetVersionOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiGetVersionOutputT');
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.STRING, 1);
    output.writeString(this.version);
    output.writeFieldEnd();
  }
  if (this.apiVersionSignatureFull !== null && this.apiVersionSignatureFull !== undefined) {
    output.writeFieldBegin('apiVersionSignatureFull', Thrift.Type.STRING, 2);
    output.writeString(this.apiVersionSignatureFull);
    output.writeFieldEnd();
  }
  if (this.apiVersionSignatureShort !== null && this.apiVersionSignatureShort !== undefined) {
    output.writeFieldBegin('apiVersionSignatureShort', Thrift.Type.I32, 3);
    output.writeI32(this.apiVersionSignatureShort);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiAggregateOutputT = function(args) {
  this.status = null;
  this.jsonAnswer = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.jsonAnswer !== undefined) {
      this.jsonAnswer = args.jsonAnswer;
    }
  }
};
XcalarApiAggregateOutputT.prototype = {};
XcalarApiAggregateOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.jsonAnswer = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiAggregateOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiAggregateOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.jsonAnswer !== null && this.jsonAnswer !== undefined) {
    output.writeFieldBegin('jsonAnswer', Thrift.Type.STRING, 2);
    output.writeString(this.jsonAnswer);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiSingleQueryT = function(args) {
  this.singleQuery = null;
  this.status = null;
  if (args) {
    if (args.singleQuery !== undefined) {
      this.singleQuery = args.singleQuery;
    }
    if (args.status !== undefined) {
      this.status = args.status;
    }
  }
};
XcalarApiSingleQueryT.prototype = {};
XcalarApiSingleQueryT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.singleQuery = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiSingleQueryT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiSingleQueryT');
  if (this.singleQuery !== null && this.singleQuery !== undefined) {
    output.writeFieldBegin('singleQuery', Thrift.Type.STRING, 1);
    output.writeString(this.singleQuery);
    output.writeFieldEnd();
  }
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 2);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiQueryStateOutputT = function(args) {
  this.queryState = null;
  this.queryStatus = null;
  this.query = null;
  this.numQueuedWorkItem = null;
  this.numRunningWorkItem = null;
  this.numCompletedWorkItem = null;
  this.numFailedWorkItem = null;
  this.failedSingleQueryArray = null;
  if (args) {
    if (args.queryState !== undefined) {
      this.queryState = args.queryState;
    }
    if (args.queryStatus !== undefined) {
      this.queryStatus = args.queryStatus;
    }
    if (args.query !== undefined) {
      this.query = args.query;
    }
    if (args.numQueuedWorkItem !== undefined) {
      this.numQueuedWorkItem = args.numQueuedWorkItem;
    }
    if (args.numRunningWorkItem !== undefined) {
      this.numRunningWorkItem = args.numRunningWorkItem;
    }
    if (args.numCompletedWorkItem !== undefined) {
      this.numCompletedWorkItem = args.numCompletedWorkItem;
    }
    if (args.numFailedWorkItem !== undefined) {
      this.numFailedWorkItem = args.numFailedWorkItem;
    }
    if (args.failedSingleQueryArray !== undefined) {
      this.failedSingleQueryArray = args.failedSingleQueryArray;
    }
  }
};
XcalarApiQueryStateOutputT.prototype = {};
XcalarApiQueryStateOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.queryState = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.queryStatus = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.query = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I64) {
        this.numQueuedWorkItem = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.numRunningWorkItem = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.numCompletedWorkItem = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I64) {
        this.numFailedWorkItem = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.LIST) {
        var _size88 = 0;
        var _rtmp392;
        this.failedSingleQueryArray = [];
        var _etype91 = 0;
        _rtmp392 = input.readListBegin();
        _etype91 = _rtmp392.etype;
        _size88 = _rtmp392.size;
        for (var _i93 = 0; _i93 < _size88; ++_i93)
        {
          var elem94 = null;
          elem94 = new XcalarApiSingleQueryT();
          elem94.read(input);
          this.failedSingleQueryArray.push(elem94);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiQueryStateOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiQueryStateOutputT');
  if (this.queryState !== null && this.queryState !== undefined) {
    output.writeFieldBegin('queryState', Thrift.Type.I32, 1);
    output.writeI32(this.queryState);
    output.writeFieldEnd();
  }
  if (this.queryStatus !== null && this.queryStatus !== undefined) {
    output.writeFieldBegin('queryStatus', Thrift.Type.I32, 2);
    output.writeI32(this.queryStatus);
    output.writeFieldEnd();
  }
  if (this.query !== null && this.query !== undefined) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 3);
    output.writeString(this.query);
    output.writeFieldEnd();
  }
  if (this.numQueuedWorkItem !== null && this.numQueuedWorkItem !== undefined) {
    output.writeFieldBegin('numQueuedWorkItem', Thrift.Type.I64, 4);
    output.writeI64(this.numQueuedWorkItem);
    output.writeFieldEnd();
  }
  if (this.numRunningWorkItem !== null && this.numRunningWorkItem !== undefined) {
    output.writeFieldBegin('numRunningWorkItem', Thrift.Type.I64, 5);
    output.writeI64(this.numRunningWorkItem);
    output.writeFieldEnd();
  }
  if (this.numCompletedWorkItem !== null && this.numCompletedWorkItem !== undefined) {
    output.writeFieldBegin('numCompletedWorkItem', Thrift.Type.I64, 6);
    output.writeI64(this.numCompletedWorkItem);
    output.writeFieldEnd();
  }
  if (this.numFailedWorkItem !== null && this.numFailedWorkItem !== undefined) {
    output.writeFieldBegin('numFailedWorkItem', Thrift.Type.I64, 7);
    output.writeI64(this.numFailedWorkItem);
    output.writeFieldEnd();
  }
  if (this.failedSingleQueryArray !== null && this.failedSingleQueryArray !== undefined) {
    output.writeFieldBegin('failedSingleQueryArray', Thrift.Type.LIST, 8);
    output.writeListBegin(Thrift.Type.STRUCT, this.failedSingleQueryArray.length);
    for (var iter95 in this.failedSingleQueryArray)
    {
      if (this.failedSingleQueryArray.hasOwnProperty(iter95))
      {
        iter95 = this.failedSingleQueryArray[iter95];
        iter95.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiInputT = function(args) {
  this.loadInput = null;
  this.indexInput = null;
  this.statInput = null;
  this.tableInput = null;
  this.resultSetNextInput = null;
  this.joinInput = null;
  this.filterInput = null;
  this.groupByInput = null;
  this.editColInput = null;
  this.resultSetAbsoluteInput = null;
  this.freeResultSetInput = null;
  this.deleteTableInput = null;
  this.getTableRefCountInput = null;
  this.listTablesInput = null;
  this.bulkDeleteTablesInput = null;
  this.queryInput = null;
  this.destroyDsInput = null;
  this.statByGroupIdInput = null;
  this.makeResultSetInput = null;
  this.mapInput = null;
  this.aggregateInput = null;
  this.queryStateInput = null;
  this.exportInput = null;
  this.dagTableNameInput = null;
  this.listFilesInput = null;
  this.startNodesInput = null;
  this.makeRetinaInput = null;
  this.getRetinaInput = null;
  this.executeRetinaInput = null;
  this.updateRetinaInput = null;
  this.addParameterToRetinaInput = null;
  this.listParametersInRetinaInput = null;
  if (args) {
    if (args.loadInput !== undefined) {
      this.loadInput = args.loadInput;
    }
    if (args.indexInput !== undefined) {
      this.indexInput = args.indexInput;
    }
    if (args.statInput !== undefined) {
      this.statInput = args.statInput;
    }
    if (args.tableInput !== undefined) {
      this.tableInput = args.tableInput;
    }
    if (args.resultSetNextInput !== undefined) {
      this.resultSetNextInput = args.resultSetNextInput;
    }
    if (args.joinInput !== undefined) {
      this.joinInput = args.joinInput;
    }
    if (args.filterInput !== undefined) {
      this.filterInput = args.filterInput;
    }
    if (args.groupByInput !== undefined) {
      this.groupByInput = args.groupByInput;
    }
    if (args.editColInput !== undefined) {
      this.editColInput = args.editColInput;
    }
    if (args.resultSetAbsoluteInput !== undefined) {
      this.resultSetAbsoluteInput = args.resultSetAbsoluteInput;
    }
    if (args.freeResultSetInput !== undefined) {
      this.freeResultSetInput = args.freeResultSetInput;
    }
    if (args.deleteTableInput !== undefined) {
      this.deleteTableInput = args.deleteTableInput;
    }
    if (args.getTableRefCountInput !== undefined) {
      this.getTableRefCountInput = args.getTableRefCountInput;
    }
    if (args.listTablesInput !== undefined) {
      this.listTablesInput = args.listTablesInput;
    }
    if (args.bulkDeleteTablesInput !== undefined) {
      this.bulkDeleteTablesInput = args.bulkDeleteTablesInput;
    }
    if (args.queryInput !== undefined) {
      this.queryInput = args.queryInput;
    }
    if (args.destroyDsInput !== undefined) {
      this.destroyDsInput = args.destroyDsInput;
    }
    if (args.statByGroupIdInput !== undefined) {
      this.statByGroupIdInput = args.statByGroupIdInput;
    }
    if (args.makeResultSetInput !== undefined) {
      this.makeResultSetInput = args.makeResultSetInput;
    }
    if (args.mapInput !== undefined) {
      this.mapInput = args.mapInput;
    }
    if (args.aggregateInput !== undefined) {
      this.aggregateInput = args.aggregateInput;
    }
    if (args.queryStateInput !== undefined) {
      this.queryStateInput = args.queryStateInput;
    }
    if (args.exportInput !== undefined) {
      this.exportInput = args.exportInput;
    }
    if (args.dagTableNameInput !== undefined) {
      this.dagTableNameInput = args.dagTableNameInput;
    }
    if (args.listFilesInput !== undefined) {
      this.listFilesInput = args.listFilesInput;
    }
    if (args.startNodesInput !== undefined) {
      this.startNodesInput = args.startNodesInput;
    }
    if (args.makeRetinaInput !== undefined) {
      this.makeRetinaInput = args.makeRetinaInput;
    }
    if (args.getRetinaInput !== undefined) {
      this.getRetinaInput = args.getRetinaInput;
    }
    if (args.executeRetinaInput !== undefined) {
      this.executeRetinaInput = args.executeRetinaInput;
    }
    if (args.updateRetinaInput !== undefined) {
      this.updateRetinaInput = args.updateRetinaInput;
    }
    if (args.addParameterToRetinaInput !== undefined) {
      this.addParameterToRetinaInput = args.addParameterToRetinaInput;
    }
    if (args.listParametersInRetinaInput !== undefined) {
      this.listParametersInRetinaInput = args.listParametersInRetinaInput;
    }
  }
};
XcalarApiInputT.prototype = {};
XcalarApiInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.loadInput = new XcalarApiBulkLoadInputT();
        this.loadInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.indexInput = new XcalarApiIndexInputT();
        this.indexInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.statInput = new XcalarApiStatInputT();
        this.statInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.tableInput = new XcalarApiTableT();
        this.tableInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.resultSetNextInput = new XcalarApiResultSetNextInputT();
        this.resultSetNextInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.joinInput = new XcalarApiJoinInputT();
        this.joinInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRUCT) {
        this.filterInput = new XcalarApiFilterInputT();
        this.filterInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.groupByInput = new XcalarApiGroupByInputT();
        this.groupByInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRUCT) {
        this.editColInput = new XcalarApiEditColInputT();
        this.editColInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.STRUCT) {
        this.resultSetAbsoluteInput = new XcalarApiResultSetAbsoluteInputT();
        this.resultSetAbsoluteInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.STRUCT) {
        this.freeResultSetInput = new XcalarApiFreeResultSetInputT();
        this.freeResultSetInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.STRUCT) {
        this.deleteTableInput = new XcalarApiTableT();
        this.deleteTableInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.STRUCT) {
        this.getTableRefCountInput = new XcalarApiTableT();
        this.getTableRefCountInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 15:
      if (ftype == Thrift.Type.STRING) {
        this.listTablesInput = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 16:
      if (ftype == Thrift.Type.STRING) {
        this.bulkDeleteTablesInput = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 17:
      if (ftype == Thrift.Type.STRING) {
        this.queryInput = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 18:
      if (ftype == Thrift.Type.STRING) {
        this.destroyDsInput = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 19:
      if (ftype == Thrift.Type.STRUCT) {
        this.statByGroupIdInput = new XcalarApiStatByGroupIdInputT();
        this.statByGroupIdInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 20:
      if (ftype == Thrift.Type.STRUCT) {
        this.makeResultSetInput = new XcalarApiNamedInputT();
        this.makeResultSetInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 21:
      if (ftype == Thrift.Type.STRUCT) {
        this.mapInput = new XcalarApiMapInputT();
        this.mapInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 22:
      if (ftype == Thrift.Type.STRUCT) {
        this.aggregateInput = new XcalarApiAggregateInputT();
        this.aggregateInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 23:
      if (ftype == Thrift.Type.STRUCT) {
        this.queryStateInput = new XcalarApiQueryStateInputT();
        this.queryStateInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 24:
      if (ftype == Thrift.Type.STRUCT) {
        this.exportInput = new XcalarApiExportInputT();
        this.exportInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 25:
      if (ftype == Thrift.Type.STRING) {
        this.dagTableNameInput = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 26:
      if (ftype == Thrift.Type.STRUCT) {
        this.listFilesInput = new XcalarApiListFilesInputT();
        this.listFilesInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 27:
      if (ftype == Thrift.Type.STRUCT) {
        this.startNodesInput = new XcalarApiStartNodesInputT();
        this.startNodesInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 28:
      if (ftype == Thrift.Type.STRUCT) {
        this.makeRetinaInput = new XcalarApiMakeRetinaInputT();
        this.makeRetinaInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 29:
      if (ftype == Thrift.Type.STRING) {
        this.getRetinaInput = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 30:
      if (ftype == Thrift.Type.STRUCT) {
        this.executeRetinaInput = new XcalarApiExecuteRetinaInputT();
        this.executeRetinaInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 31:
      if (ftype == Thrift.Type.STRUCT) {
        this.updateRetinaInput = new XcalarApiUpdateRetinaInputT();
        this.updateRetinaInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 32:
      if (ftype == Thrift.Type.STRUCT) {
        this.addParameterToRetinaInput = new XcalarApiAddParameterToRetinaInputT();
        this.addParameterToRetinaInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 33:
      if (ftype == Thrift.Type.STRING) {
        this.listParametersInRetinaInput = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiInputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiInputT');
  if (this.loadInput !== null && this.loadInput !== undefined) {
    output.writeFieldBegin('loadInput', Thrift.Type.STRUCT, 1);
    this.loadInput.write(output);
    output.writeFieldEnd();
  }
  if (this.indexInput !== null && this.indexInput !== undefined) {
    output.writeFieldBegin('indexInput', Thrift.Type.STRUCT, 2);
    this.indexInput.write(output);
    output.writeFieldEnd();
  }
  if (this.statInput !== null && this.statInput !== undefined) {
    output.writeFieldBegin('statInput', Thrift.Type.STRUCT, 3);
    this.statInput.write(output);
    output.writeFieldEnd();
  }
  if (this.tableInput !== null && this.tableInput !== undefined) {
    output.writeFieldBegin('tableInput', Thrift.Type.STRUCT, 4);
    this.tableInput.write(output);
    output.writeFieldEnd();
  }
  if (this.resultSetNextInput !== null && this.resultSetNextInput !== undefined) {
    output.writeFieldBegin('resultSetNextInput', Thrift.Type.STRUCT, 5);
    this.resultSetNextInput.write(output);
    output.writeFieldEnd();
  }
  if (this.joinInput !== null && this.joinInput !== undefined) {
    output.writeFieldBegin('joinInput', Thrift.Type.STRUCT, 6);
    this.joinInput.write(output);
    output.writeFieldEnd();
  }
  if (this.filterInput !== null && this.filterInput !== undefined) {
    output.writeFieldBegin('filterInput', Thrift.Type.STRUCT, 7);
    this.filterInput.write(output);
    output.writeFieldEnd();
  }
  if (this.groupByInput !== null && this.groupByInput !== undefined) {
    output.writeFieldBegin('groupByInput', Thrift.Type.STRUCT, 8);
    this.groupByInput.write(output);
    output.writeFieldEnd();
  }
  if (this.editColInput !== null && this.editColInput !== undefined) {
    output.writeFieldBegin('editColInput', Thrift.Type.STRUCT, 10);
    this.editColInput.write(output);
    output.writeFieldEnd();
  }
  if (this.resultSetAbsoluteInput !== null && this.resultSetAbsoluteInput !== undefined) {
    output.writeFieldBegin('resultSetAbsoluteInput', Thrift.Type.STRUCT, 11);
    this.resultSetAbsoluteInput.write(output);
    output.writeFieldEnd();
  }
  if (this.freeResultSetInput !== null && this.freeResultSetInput !== undefined) {
    output.writeFieldBegin('freeResultSetInput', Thrift.Type.STRUCT, 12);
    this.freeResultSetInput.write(output);
    output.writeFieldEnd();
  }
  if (this.deleteTableInput !== null && this.deleteTableInput !== undefined) {
    output.writeFieldBegin('deleteTableInput', Thrift.Type.STRUCT, 13);
    this.deleteTableInput.write(output);
    output.writeFieldEnd();
  }
  if (this.getTableRefCountInput !== null && this.getTableRefCountInput !== undefined) {
    output.writeFieldBegin('getTableRefCountInput', Thrift.Type.STRUCT, 14);
    this.getTableRefCountInput.write(output);
    output.writeFieldEnd();
  }
  if (this.listTablesInput !== null && this.listTablesInput !== undefined) {
    output.writeFieldBegin('listTablesInput', Thrift.Type.STRING, 15);
    output.writeString(this.listTablesInput);
    output.writeFieldEnd();
  }
  if (this.bulkDeleteTablesInput !== null && this.bulkDeleteTablesInput !== undefined) {
    output.writeFieldBegin('bulkDeleteTablesInput', Thrift.Type.STRING, 16);
    output.writeString(this.bulkDeleteTablesInput);
    output.writeFieldEnd();
  }
  if (this.queryInput !== null && this.queryInput !== undefined) {
    output.writeFieldBegin('queryInput', Thrift.Type.STRING, 17);
    output.writeString(this.queryInput);
    output.writeFieldEnd();
  }
  if (this.destroyDsInput !== null && this.destroyDsInput !== undefined) {
    output.writeFieldBegin('destroyDsInput', Thrift.Type.STRING, 18);
    output.writeString(this.destroyDsInput);
    output.writeFieldEnd();
  }
  if (this.statByGroupIdInput !== null && this.statByGroupIdInput !== undefined) {
    output.writeFieldBegin('statByGroupIdInput', Thrift.Type.STRUCT, 19);
    this.statByGroupIdInput.write(output);
    output.writeFieldEnd();
  }
  if (this.makeResultSetInput !== null && this.makeResultSetInput !== undefined) {
    output.writeFieldBegin('makeResultSetInput', Thrift.Type.STRUCT, 20);
    this.makeResultSetInput.write(output);
    output.writeFieldEnd();
  }
  if (this.mapInput !== null && this.mapInput !== undefined) {
    output.writeFieldBegin('mapInput', Thrift.Type.STRUCT, 21);
    this.mapInput.write(output);
    output.writeFieldEnd();
  }
  if (this.aggregateInput !== null && this.aggregateInput !== undefined) {
    output.writeFieldBegin('aggregateInput', Thrift.Type.STRUCT, 22);
    this.aggregateInput.write(output);
    output.writeFieldEnd();
  }
  if (this.queryStateInput !== null && this.queryStateInput !== undefined) {
    output.writeFieldBegin('queryStateInput', Thrift.Type.STRUCT, 23);
    this.queryStateInput.write(output);
    output.writeFieldEnd();
  }
  if (this.exportInput !== null && this.exportInput !== undefined) {
    output.writeFieldBegin('exportInput', Thrift.Type.STRUCT, 24);
    this.exportInput.write(output);
    output.writeFieldEnd();
  }
  if (this.dagTableNameInput !== null && this.dagTableNameInput !== undefined) {
    output.writeFieldBegin('dagTableNameInput', Thrift.Type.STRING, 25);
    output.writeString(this.dagTableNameInput);
    output.writeFieldEnd();
  }
  if (this.listFilesInput !== null && this.listFilesInput !== undefined) {
    output.writeFieldBegin('listFilesInput', Thrift.Type.STRUCT, 26);
    this.listFilesInput.write(output);
    output.writeFieldEnd();
  }
  if (this.startNodesInput !== null && this.startNodesInput !== undefined) {
    output.writeFieldBegin('startNodesInput', Thrift.Type.STRUCT, 27);
    this.startNodesInput.write(output);
    output.writeFieldEnd();
  }
  if (this.makeRetinaInput !== null && this.makeRetinaInput !== undefined) {
    output.writeFieldBegin('makeRetinaInput', Thrift.Type.STRUCT, 28);
    this.makeRetinaInput.write(output);
    output.writeFieldEnd();
  }
  if (this.getRetinaInput !== null && this.getRetinaInput !== undefined) {
    output.writeFieldBegin('getRetinaInput', Thrift.Type.STRING, 29);
    output.writeString(this.getRetinaInput);
    output.writeFieldEnd();
  }
  if (this.executeRetinaInput !== null && this.executeRetinaInput !== undefined) {
    output.writeFieldBegin('executeRetinaInput', Thrift.Type.STRUCT, 30);
    this.executeRetinaInput.write(output);
    output.writeFieldEnd();
  }
  if (this.updateRetinaInput !== null && this.updateRetinaInput !== undefined) {
    output.writeFieldBegin('updateRetinaInput', Thrift.Type.STRUCT, 31);
    this.updateRetinaInput.write(output);
    output.writeFieldEnd();
  }
  if (this.addParameterToRetinaInput !== null && this.addParameterToRetinaInput !== undefined) {
    output.writeFieldBegin('addParameterToRetinaInput', Thrift.Type.STRUCT, 32);
    this.addParameterToRetinaInput.write(output);
    output.writeFieldEnd();
  }
  if (this.listParametersInRetinaInput !== null && this.listParametersInRetinaInput !== undefined) {
    output.writeFieldBegin('listParametersInRetinaInput', Thrift.Type.STRING, 33);
    output.writeString(this.listParametersInRetinaInput);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiDagNodeT = function(args) {
  this.dagNodeId = null;
  this.api = null;
  this.input = null;
  if (args) {
    if (args.dagNodeId !== undefined) {
      this.dagNodeId = args.dagNodeId;
    }
    if (args.api !== undefined) {
      this.api = args.api;
    }
    if (args.input !== undefined) {
      this.input = args.input;
    }
  }
};
XcalarApiDagNodeT.prototype = {};
XcalarApiDagNodeT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.dagNodeId = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.api = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.input = new XcalarApiInputT();
        this.input.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiDagNodeT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiDagNodeT');
  if (this.dagNodeId !== null && this.dagNodeId !== undefined) {
    output.writeFieldBegin('dagNodeId', Thrift.Type.I64, 1);
    output.writeI64(this.dagNodeId);
    output.writeFieldEnd();
  }
  if (this.api !== null && this.api !== undefined) {
    output.writeFieldBegin('api', Thrift.Type.I32, 2);
    output.writeI32(this.api);
    output.writeFieldEnd();
  }
  if (this.input !== null && this.input !== undefined) {
    output.writeFieldBegin('input', Thrift.Type.STRUCT, 3);
    this.input.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiDagOutputT = function(args) {
  this.status = null;
  this.numNodes = null;
  this.node = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.numNodes !== undefined) {
      this.numNodes = args.numNodes;
    }
    if (args.node !== undefined) {
      this.node = args.node;
    }
  }
};
XcalarApiDagOutputT.prototype = {};
XcalarApiDagOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numNodes = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size96 = 0;
        var _rtmp3100;
        this.node = [];
        var _etype99 = 0;
        _rtmp3100 = input.readListBegin();
        _etype99 = _rtmp3100.etype;
        _size96 = _rtmp3100.size;
        for (var _i101 = 0; _i101 < _size96; ++_i101)
        {
          var elem102 = null;
          elem102 = new XcalarApiDagNodeT();
          elem102.read(input);
          this.node.push(elem102);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiDagOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiDagOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.numNodes !== null && this.numNodes !== undefined) {
    output.writeFieldBegin('numNodes', Thrift.Type.I64, 2);
    output.writeI64(this.numNodes);
    output.writeFieldEnd();
  }
  if (this.node !== null && this.node !== undefined) {
    output.writeFieldBegin('node', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.node.length);
    for (var iter103 in this.node)
    {
      if (this.node.hasOwnProperty(iter103))
      {
        iter103 = this.node[iter103];
        iter103.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiRetinaDescT = function(args) {
  this.retinaName = null;
  if (args) {
    if (args.retinaName !== undefined) {
      this.retinaName = args.retinaName;
    }
  }
};
XcalarApiRetinaDescT.prototype = {};
XcalarApiRetinaDescT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.retinaName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiRetinaDescT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiRetinaDescT');
  if (this.retinaName !== null && this.retinaName !== undefined) {
    output.writeFieldBegin('retinaName', Thrift.Type.STRING, 1);
    output.writeString(this.retinaName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiRetinaT = function(args) {
  this.retinaDesc = null;
  this.retinaDag = null;
  if (args) {
    if (args.retinaDesc !== undefined) {
      this.retinaDesc = args.retinaDesc;
    }
    if (args.retinaDag !== undefined) {
      this.retinaDag = args.retinaDag;
    }
  }
};
XcalarApiRetinaT.prototype = {};
XcalarApiRetinaT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.retinaDesc = new XcalarApiRetinaDescT();
        this.retinaDesc.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.retinaDag = new XcalarApiDagOutputT();
        this.retinaDag.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiRetinaT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiRetinaT');
  if (this.retinaDesc !== null && this.retinaDesc !== undefined) {
    output.writeFieldBegin('retinaDesc', Thrift.Type.STRUCT, 1);
    this.retinaDesc.write(output);
    output.writeFieldEnd();
  }
  if (this.retinaDag !== null && this.retinaDag !== undefined) {
    output.writeFieldBegin('retinaDag', Thrift.Type.STRUCT, 2);
    this.retinaDag.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiListRetinasOutputT = function(args) {
  this.status = null;
  this.numRetinas = null;
  this.retinaDescs = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.numRetinas !== undefined) {
      this.numRetinas = args.numRetinas;
    }
    if (args.retinaDescs !== undefined) {
      this.retinaDescs = args.retinaDescs;
    }
  }
};
XcalarApiListRetinasOutputT.prototype = {};
XcalarApiListRetinasOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.numRetinas = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size104 = 0;
        var _rtmp3108;
        this.retinaDescs = [];
        var _etype107 = 0;
        _rtmp3108 = input.readListBegin();
        _etype107 = _rtmp3108.etype;
        _size104 = _rtmp3108.size;
        for (var _i109 = 0; _i109 < _size104; ++_i109)
        {
          var elem110 = null;
          elem110 = new XcalarApiRetinaDescT();
          elem110.read(input);
          this.retinaDescs.push(elem110);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiListRetinasOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiListRetinasOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.numRetinas !== null && this.numRetinas !== undefined) {
    output.writeFieldBegin('numRetinas', Thrift.Type.I64, 2);
    output.writeI64(this.numRetinas);
    output.writeFieldEnd();
  }
  if (this.retinaDescs !== null && this.retinaDescs !== undefined) {
    output.writeFieldBegin('retinaDescs', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.retinaDescs.length);
    for (var iter111 in this.retinaDescs)
    {
      if (this.retinaDescs.hasOwnProperty(iter111))
      {
        iter111 = this.retinaDescs[iter111];
        iter111.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiGetRetinaOutputT = function(args) {
  this.status = null;
  this.retina = null;
  if (args) {
    if (args.status !== undefined) {
      this.status = args.status;
    }
    if (args.retina !== undefined) {
      this.retina = args.retina;
    }
  }
};
XcalarApiGetRetinaOutputT.prototype = {};
XcalarApiGetRetinaOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.retina = new XcalarApiRetinaT();
        this.retina.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiGetRetinaOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiGetRetinaOutputT');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 1);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.retina !== null && this.retina !== undefined) {
    output.writeFieldBegin('retina', Thrift.Type.STRUCT, 2);
    this.retina.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiOutputT = function(args) {
  this.getVersionOutput = null;
  this.statusOutput = null;
  this.statOutput = null;
  this.listTablesOutput = null;
  this.makeResultSetOutput = null;
  this.resultSetNextOutput = null;
  this.countOutput = null;
  this.indexOutput = null;
  this.loadOutput = null;
  this.getTableRefCountOutput = null;
  this.deleteTablesOutput = null;
  this.joinOutput = null;
  this.statGroupIdMapOutput = null;
  this.listDatasetsOutput = null;
  this.mapOutput = null;
  this.aggregateOutput = null;
  this.filterOutput = null;
  this.queryOutput = null;
  this.queryStateOutput = null;
  this.exportOutput = null;
  this.dagOutput = null;
  this.listFilesOutput = null;
  this.groupByOutput = null;
  this.listRetinasOutput = null;
  this.getRetinaOutput = null;
  this.listParametersInRetinaOutput = null;
  if (args) {
    if (args.getVersionOutput !== undefined) {
      this.getVersionOutput = args.getVersionOutput;
    }
    if (args.statusOutput !== undefined) {
      this.statusOutput = args.statusOutput;
    }
    if (args.statOutput !== undefined) {
      this.statOutput = args.statOutput;
    }
    if (args.listTablesOutput !== undefined) {
      this.listTablesOutput = args.listTablesOutput;
    }
    if (args.makeResultSetOutput !== undefined) {
      this.makeResultSetOutput = args.makeResultSetOutput;
    }
    if (args.resultSetNextOutput !== undefined) {
      this.resultSetNextOutput = args.resultSetNextOutput;
    }
    if (args.countOutput !== undefined) {
      this.countOutput = args.countOutput;
    }
    if (args.indexOutput !== undefined) {
      this.indexOutput = args.indexOutput;
    }
    if (args.loadOutput !== undefined) {
      this.loadOutput = args.loadOutput;
    }
    if (args.getTableRefCountOutput !== undefined) {
      this.getTableRefCountOutput = args.getTableRefCountOutput;
    }
    if (args.deleteTablesOutput !== undefined) {
      this.deleteTablesOutput = args.deleteTablesOutput;
    }
    if (args.joinOutput !== undefined) {
      this.joinOutput = args.joinOutput;
    }
    if (args.statGroupIdMapOutput !== undefined) {
      this.statGroupIdMapOutput = args.statGroupIdMapOutput;
    }
    if (args.listDatasetsOutput !== undefined) {
      this.listDatasetsOutput = args.listDatasetsOutput;
    }
    if (args.mapOutput !== undefined) {
      this.mapOutput = args.mapOutput;
    }
    if (args.aggregateOutput !== undefined) {
      this.aggregateOutput = args.aggregateOutput;
    }
    if (args.filterOutput !== undefined) {
      this.filterOutput = args.filterOutput;
    }
    if (args.queryOutput !== undefined) {
      this.queryOutput = args.queryOutput;
    }
    if (args.queryStateOutput !== undefined) {
      this.queryStateOutput = args.queryStateOutput;
    }
    if (args.exportOutput !== undefined) {
      this.exportOutput = args.exportOutput;
    }
    if (args.dagOutput !== undefined) {
      this.dagOutput = args.dagOutput;
    }
    if (args.listFilesOutput !== undefined) {
      this.listFilesOutput = args.listFilesOutput;
    }
    if (args.groupByOutput !== undefined) {
      this.groupByOutput = args.groupByOutput;
    }
    if (args.listRetinasOutput !== undefined) {
      this.listRetinasOutput = args.listRetinasOutput;
    }
    if (args.getRetinaOutput !== undefined) {
      this.getRetinaOutput = args.getRetinaOutput;
    }
    if (args.listParametersInRetinaOutput !== undefined) {
      this.listParametersInRetinaOutput = args.listParametersInRetinaOutput;
    }
  }
};
XcalarApiOutputT.prototype = {};
XcalarApiOutputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.getVersionOutput = new XcalarApiGetVersionOutputT();
        this.getVersionOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.statusOutput = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.statOutput = new XcalarApiGetStatOutputT();
        this.statOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.listTablesOutput = new XcalarApiListTablesOutputT();
        this.listTablesOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.makeResultSetOutput = new XcalarApiMakeResultSetOutputT();
        this.makeResultSetOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.resultSetNextOutput = new XcalarApiResultSetNextOutputT();
        this.resultSetNextOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRUCT) {
        this.countOutput = new XcalarApiCountOutputT();
        this.countOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.indexOutput = new XcalarApiNewTableOutputT();
        this.indexOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.STRUCT) {
        this.loadOutput = new XcalarApiBulkLoadOutputT();
        this.loadOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRUCT) {
        this.getTableRefCountOutput = new XcalarApiGetTableRefCountOutputT();
        this.getTableRefCountOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.STRUCT) {
        this.deleteTablesOutput = new XcalarApiBulkDeleteTablesOutputT();
        this.deleteTablesOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.STRUCT) {
        this.joinOutput = new XcalarApiNewTableOutputT();
        this.joinOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.STRUCT) {
        this.statGroupIdMapOutput = new XcalarApiGetStatGroupIdMapOutputT();
        this.statGroupIdMapOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.STRUCT) {
        this.listDatasetsOutput = new XcalarApiListDatasetsOutputT();
        this.listDatasetsOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 15:
      if (ftype == Thrift.Type.STRUCT) {
        this.mapOutput = new XcalarApiNewTableOutputT();
        this.mapOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 16:
      if (ftype == Thrift.Type.STRUCT) {
        this.aggregateOutput = new XcalarApiAggregateOutputT();
        this.aggregateOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 17:
      if (ftype == Thrift.Type.STRUCT) {
        this.filterOutput = new XcalarApiNewTableOutputT();
        this.filterOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 18:
      if (ftype == Thrift.Type.STRUCT) {
        this.queryOutput = new XcalarApiQueryOutputT();
        this.queryOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 19:
      if (ftype == Thrift.Type.STRUCT) {
        this.queryStateOutput = new XcalarApiQueryStateOutputT();
        this.queryStateOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 20:
      if (ftype == Thrift.Type.STRUCT) {
        this.exportOutput = new XcalarApiExportOutputT();
        this.exportOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 21:
      if (ftype == Thrift.Type.STRUCT) {
        this.dagOutput = new XcalarApiDagOutputT();
        this.dagOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 22:
      if (ftype == Thrift.Type.STRUCT) {
        this.listFilesOutput = new XcalarApiListFilesOutputT();
        this.listFilesOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 23:
      if (ftype == Thrift.Type.STRUCT) {
        this.groupByOutput = new XcalarApiNewTableOutputT();
        this.groupByOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 24:
      if (ftype == Thrift.Type.STRUCT) {
        this.listRetinasOutput = new XcalarApiListRetinasOutputT();
        this.listRetinasOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 25:
      if (ftype == Thrift.Type.STRUCT) {
        this.getRetinaOutput = new XcalarApiGetRetinaOutputT();
        this.getRetinaOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 26:
      if (ftype == Thrift.Type.STRUCT) {
        this.listParametersInRetinaOutput = new XcalarApiListParametersInRetinaOutputT();
        this.listParametersInRetinaOutput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiOutputT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiOutputT');
  if (this.getVersionOutput !== null && this.getVersionOutput !== undefined) {
    output.writeFieldBegin('getVersionOutput', Thrift.Type.STRUCT, 1);
    this.getVersionOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.statusOutput !== null && this.statusOutput !== undefined) {
    output.writeFieldBegin('statusOutput', Thrift.Type.I32, 2);
    output.writeI32(this.statusOutput);
    output.writeFieldEnd();
  }
  if (this.statOutput !== null && this.statOutput !== undefined) {
    output.writeFieldBegin('statOutput', Thrift.Type.STRUCT, 3);
    this.statOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.listTablesOutput !== null && this.listTablesOutput !== undefined) {
    output.writeFieldBegin('listTablesOutput', Thrift.Type.STRUCT, 4);
    this.listTablesOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.makeResultSetOutput !== null && this.makeResultSetOutput !== undefined) {
    output.writeFieldBegin('makeResultSetOutput', Thrift.Type.STRUCT, 5);
    this.makeResultSetOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.resultSetNextOutput !== null && this.resultSetNextOutput !== undefined) {
    output.writeFieldBegin('resultSetNextOutput', Thrift.Type.STRUCT, 6);
    this.resultSetNextOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.countOutput !== null && this.countOutput !== undefined) {
    output.writeFieldBegin('countOutput', Thrift.Type.STRUCT, 7);
    this.countOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.indexOutput !== null && this.indexOutput !== undefined) {
    output.writeFieldBegin('indexOutput', Thrift.Type.STRUCT, 8);
    this.indexOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.loadOutput !== null && this.loadOutput !== undefined) {
    output.writeFieldBegin('loadOutput', Thrift.Type.STRUCT, 9);
    this.loadOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.getTableRefCountOutput !== null && this.getTableRefCountOutput !== undefined) {
    output.writeFieldBegin('getTableRefCountOutput', Thrift.Type.STRUCT, 10);
    this.getTableRefCountOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.deleteTablesOutput !== null && this.deleteTablesOutput !== undefined) {
    output.writeFieldBegin('deleteTablesOutput', Thrift.Type.STRUCT, 11);
    this.deleteTablesOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.joinOutput !== null && this.joinOutput !== undefined) {
    output.writeFieldBegin('joinOutput', Thrift.Type.STRUCT, 12);
    this.joinOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.statGroupIdMapOutput !== null && this.statGroupIdMapOutput !== undefined) {
    output.writeFieldBegin('statGroupIdMapOutput', Thrift.Type.STRUCT, 13);
    this.statGroupIdMapOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.listDatasetsOutput !== null && this.listDatasetsOutput !== undefined) {
    output.writeFieldBegin('listDatasetsOutput', Thrift.Type.STRUCT, 14);
    this.listDatasetsOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.mapOutput !== null && this.mapOutput !== undefined) {
    output.writeFieldBegin('mapOutput', Thrift.Type.STRUCT, 15);
    this.mapOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.aggregateOutput !== null && this.aggregateOutput !== undefined) {
    output.writeFieldBegin('aggregateOutput', Thrift.Type.STRUCT, 16);
    this.aggregateOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.filterOutput !== null && this.filterOutput !== undefined) {
    output.writeFieldBegin('filterOutput', Thrift.Type.STRUCT, 17);
    this.filterOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.queryOutput !== null && this.queryOutput !== undefined) {
    output.writeFieldBegin('queryOutput', Thrift.Type.STRUCT, 18);
    this.queryOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.queryStateOutput !== null && this.queryStateOutput !== undefined) {
    output.writeFieldBegin('queryStateOutput', Thrift.Type.STRUCT, 19);
    this.queryStateOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.exportOutput !== null && this.exportOutput !== undefined) {
    output.writeFieldBegin('exportOutput', Thrift.Type.STRUCT, 20);
    this.exportOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.dagOutput !== null && this.dagOutput !== undefined) {
    output.writeFieldBegin('dagOutput', Thrift.Type.STRUCT, 21);
    this.dagOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.listFilesOutput !== null && this.listFilesOutput !== undefined) {
    output.writeFieldBegin('listFilesOutput', Thrift.Type.STRUCT, 22);
    this.listFilesOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.groupByOutput !== null && this.groupByOutput !== undefined) {
    output.writeFieldBegin('groupByOutput', Thrift.Type.STRUCT, 23);
    this.groupByOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.listRetinasOutput !== null && this.listRetinasOutput !== undefined) {
    output.writeFieldBegin('listRetinasOutput', Thrift.Type.STRUCT, 24);
    this.listRetinasOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.getRetinaOutput !== null && this.getRetinaOutput !== undefined) {
    output.writeFieldBegin('getRetinaOutput', Thrift.Type.STRUCT, 25);
    this.getRetinaOutput.write(output);
    output.writeFieldEnd();
  }
  if (this.listParametersInRetinaOutput !== null && this.listParametersInRetinaOutput !== undefined) {
    output.writeFieldBegin('listParametersInRetinaOutput', Thrift.Type.STRUCT, 26);
    this.listParametersInRetinaOutput.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiWorkItemT = function(args) {
  this.apiVersionSignature = null;
  this.api = null;
  this.input = null;
  if (args) {
    if (args.apiVersionSignature !== undefined) {
      this.apiVersionSignature = args.apiVersionSignature;
    }
    if (args.api !== undefined) {
      this.api = args.api;
    }
    if (args.input !== undefined) {
      this.input = args.input;
    }
  }
};
XcalarApiWorkItemT.prototype = {};
XcalarApiWorkItemT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.apiVersionSignature = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.api = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.input = new XcalarApiInputT();
        this.input.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiWorkItemT.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiWorkItemT');
  if (this.apiVersionSignature !== null && this.apiVersionSignature !== undefined) {
    output.writeFieldBegin('apiVersionSignature', Thrift.Type.I32, 1);
    output.writeI32(this.apiVersionSignature);
    output.writeFieldEnd();
  }
  if (this.api !== null && this.api !== undefined) {
    output.writeFieldBegin('api', Thrift.Type.I32, 2);
    output.writeI32(this.api);
    output.writeFieldEnd();
  }
  if (this.input !== null && this.input !== undefined) {
    output.writeFieldBegin('input', Thrift.Type.STRUCT, 3);
    this.input.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiWorkItemResult = function(args) {
  this.jobStatus = null;
  this.output = null;
  if (args) {
    if (args.jobStatus !== undefined) {
      this.jobStatus = args.jobStatus;
    }
    if (args.output !== undefined) {
      this.output = args.output;
    }
  }
};
XcalarApiWorkItemResult.prototype = {};
XcalarApiWorkItemResult.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.jobStatus = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.output = new XcalarApiOutputT();
        this.output.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiWorkItemResult.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiWorkItemResult');
  if (this.jobStatus !== null && this.jobStatus !== undefined) {
    output.writeFieldBegin('jobStatus', Thrift.Type.I32, 1);
    output.writeI32(this.jobStatus);
    output.writeFieldEnd();
  }
  if (this.output !== null && this.output !== undefined) {
    output.writeFieldBegin('output', Thrift.Type.STRUCT, 2);
    this.output.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiDatasetIdInvalidT = 0;
XcalarApiTableIdInvalidT = 0;
XcalarApiXidInvalidT = 0;
XcalarApiDagNodeIdInvalidT = 0;
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


XcalarApiVersionT = {
'XcalarApiVersionSignature' : 54520027
};
XcalarApiVersionTStr = {54520027 : '33fe8db67bee195984433f49cc1a403d'
};
//
// Autogenerated by Thrift Compiler (0.9.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


//HELPER FUNCTIONS AND STRUCTURES

XcalarApiService_queueWork_args = function(args) {
  this.workItem = null;
  if (args) {
    if (args.workItem !== undefined) {
      this.workItem = args.workItem;
    }
  }
};
XcalarApiService_queueWork_args.prototype = {};
XcalarApiService_queueWork_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.workItem = new XcalarApiWorkItemT();
        this.workItem.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiService_queueWork_args.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiService_queueWork_args');
  if (this.workItem !== null && this.workItem !== undefined) {
    output.writeFieldBegin('workItem', Thrift.Type.STRUCT, 1);
    this.workItem.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiService_queueWork_result = function(args) {
  this.success = null;
  this.err = null;
  if (args instanceof XcalarApiException) {
    this.err = args;
    return;
  }
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.err !== undefined) {
      this.err = args.err;
    }
  }
};
XcalarApiService_queueWork_result.prototype = {};
XcalarApiService_queueWork_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new XcalarApiWorkItemResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.err = new XcalarApiException();
        this.err.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

XcalarApiService_queueWork_result.prototype.write = function(output) {
  output.writeStructBegin('XcalarApiService_queueWork_result');
  if (this.success !== null && this.success !== undefined) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.err !== null && this.err !== undefined) {
    output.writeFieldBegin('err', Thrift.Type.STRUCT, 1);
    this.err.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

XcalarApiServiceClient = function(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
};
XcalarApiServiceClient.prototype = {};
XcalarApiServiceClient.prototype.queueWork = function(workItem) {
  this.send_queueWork(workItem);
  return this.recv_queueWork();
};

XcalarApiServiceClient.prototype.send_queueWork = function(workItem) {
  this.output.writeMessageBegin('queueWork', Thrift.MessageType.CALL, this.seqid);
  var args = new XcalarApiService_queueWork_args();
  args.workItem = workItem;
  args.write(this.output);
  this.output.writeMessageEnd();
  return this.output.getTransport().flush();
};

XcalarApiServiceClient.prototype.recv_queueWork = function() {
  var ret = this.input.readMessageBegin();
  var fname = ret.fname;
  var mtype = ret.mtype;
  var rseqid = ret.rseqid;
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(this.input);
    this.input.readMessageEnd();
    throw x;
  }
  var result = new XcalarApiService_queueWork_result();
  result.read(this.input);
  this.input.readMessageEnd();

  if (null !== result.err) {
    throw result.err;
  }
  if (null !== result.success) {
    return result.success;
  }
  throw 'queueWork failed: unknown result';
};
ThriftHandle = function(args) {
    this.transport = null;
    this.protocol = null;
    this.client = null;
};

function xcalarConnectThrift(hostname, port) {
    var thriftUrl = "http://" + hostname + ":" + port.toString() +
        "/thrift/service/XcalarApiService/";

    console.log("xcalarConnectThrift(thriftUrl = " + thriftUrl + ")") 

    var transport = new Thrift.Transport(thriftUrl);
    var protocol  = new Thrift.Protocol(transport);
    var client    = new XcalarApiServiceClient(protocol);

    var thriftHandle = new ThriftHandle();
    thriftHandle.transport = transport;
    thriftHandle.protocol = protocol;
    thriftHandle.client = client;

    return thriftHandle;
}

function xcalarGetVersion(thriftHandle) {
    console.log("xcalarGetVersion()");

    var workItem = new XcalarApiWorkItemT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGetVersion;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var verOutput = result.output.getVersionOutput;
    } catch(ouch) {
        console.log("xcalarGetVersion() caught exception: " + ouch);

        var verOutput = new XcalarApiGetVersionOutputT();
        verOutput.version = "<unknown>";
        verOutput.apiVersionSignatureFull = "<unknown>";
        verOutput.apiVersionSignatureShort = 0;
    }

    return verOutput;
}

function xcalarLoad(thriftHandle, url, name, format, maxSampleSize, loadArgs) {
    console.log("xcalarLoad(url = " + url + ", name = " + name + ", format = " +
                DfFormatTypeTStr[format] + ", maxSampleSize = " +
                maxSampleSize.toString() + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.loadInput = new XcalarApiBulkLoadInputT();
    workItem.input.loadInput.dataset = new XcalarApiDatasetT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiBulkLoad;
    workItem.input.loadInput.dataset.datasetId = 0;
    workItem.input.loadInput.dataset.url = url;
    workItem.input.loadInput.dataset.name = name;
    workItem.input.loadInput.dataset.formatType = format;
    workItem.input.loadInput.maxSize = maxSampleSize;
    workItem.input.loadInput.loadArgs = loadArgs

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var loadOutput = result.output.loadOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            loadOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarLoad() caught exception: " + ouch);

        var loadOutput = new XcalarApiBulkLoadOutputT();
        loadOutput.status = StatusT.StatusThriftProtocolError;
    }

    return loadOutput;
}

function xcalarIndexDataset(thriftHandle, datasetName, keyName, dstTableName) {
    console.log("xcalarIndexDataset(datasetName = " + datasetName +
                ", keyName = " + keyName + ", dstTableName = " +
                dstTableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.indexInput = new XcalarApiIndexInputT();
    workItem.input.indexInput.source = new XcalarApiNamedInputT();
    workItem.input.indexInput.dstTable = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiIndex;
    workItem.input.indexInput.source.isTable = false;
    workItem.input.indexInput.source.name = datasetName;
    workItem.input.indexInput.source.xid = XcalarApiXidInvalidT;;
    workItem.input.indexInput.dstTable.tableName = dstTableName;
    workItem.input.indexInput.dstTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.indexInput.keyName = keyName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var indexOutput = result.output.indexOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            indexOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarIndexDataset() caught exception: " + ouch);

        var indexOutput = new XcalarApiNewTableOutputT();
        indexOutput.status = StatusT.StatusThriftProtocolError;
    }

    return indexOutput;
}

function xcalarIndexTable(thriftHandle, srcTableName, keyName, dstTableName) {
    console.log("xcalarIndexTable(srcTableName = " + srcTableName +
                ", keyName = " + keyName + ", dstTableName = " +
                dstTableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.indexInput = new XcalarApiIndexInputT();
    workItem.input.indexInput.source = new XcalarApiNamedInputT();
    workItem.input.indexInput.dstTable = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiIndex;
    workItem.input.indexInput.source.isTable = true;
    workItem.input.indexInput.source.name = srcTableName;
    workItem.input.indexInput.source.xid = XcalarApiXidInvalidT;
    workItem.input.indexInput.dstTable.tableName = dstTableName;
    workItem.input.indexInput.dstTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.indexInput.keyName = keyName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var indexOutput = result.output.indexOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            indexOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarIndexTable() caught exception: " + ouch);

        var indexOutput = new XcalarApiNewTableOutputT();
        indexOutput.status = StatusT.StatusThriftProtocolError;
    }

    return indexOutput;
}

function xcalarGetCount(thriftHandle, tableName) {
    console.log("xcalarGetCount(tableName = " + tableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.tableInput = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiCountUnique;
    workItem.input.tableInput.tableName = tableName;
    workItem.input.tableInput.tableId = XcalarApiTableIdInvalidT;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var countOutput = result.output.countOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            countOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarGetCount() caught exception: " + ouch);

        var countOutput = new XcalarApiCountOutputT();
        countOutput.status = StatusT.StatusThriftProtocolError;
    }

    return countOutput;
}

function xcalarShutdown(thriftHandle) {
    console.log("xcalarShutdown()");

    var workItem = new XcalarApiWorkItemT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiShutdown;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = StatusT.StatusOk;
        if (result.jobStatus != StatusT.StatusOk) {
            status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarShutdown() caught exception: " + ouch);
        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarStartNodes(thriftHandle, numNodes) {
    console.log("xcalarStartNodes(numNodes = " + numNodes + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.startNodesInput = new XcalarApiStartNodesInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiStartNodes;
    workItem.input.startNodesInput.numNodes = numNodes;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = StatusT.StatusOk;
        if (result.jobStatus != StatusT.StatusOk) {
            status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarStartNodes() caught exception: " + ouch);
        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarGetStats(thriftHandle, nodeId) {
    console.log("xcalarGetStats(nodeId = " + nodeId.toString() + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.statInput = new XcalarApiStatInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGetStat;
    workItem.input.statInput.nodeId = nodeId;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var statOutput = result.output.statOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            statOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarGetStats() caught exception: " + ouch);

        var statOutput = new XcalarApiGetStatOutputT();
        statOutput.status = StatusT.StatusThriftProtocolError;
        statOutput.numStats = 0;
    }

    return statOutput;
}

function xcalarEditColumn(thriftHandle, datasetName, tableName, isDataset,
                          currFieldName, newFieldName, newFieldType) {
    console.log("xcalarEditColumn(datasetName = " + datasetName +
                ", tableName = " + tableName.toString() + ", isDataset = " +
                isDataset.toString() + ", currFieldName = " +
                currFieldName.toString() + ", newFieldName = " +
                newFieldName.toString() + ", newFieldType = " +
                newFieldType.toString());

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.editColInput = new XcalarApiEditColInputT();
    workItem.input.editColInput.source = new XcalarApiNamedInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiEditColumn;
    if (isDataset) {
	workItem.input.editColInput.source.isTable = false;
	workItem.input.editColInput.source.name = datasetName;
	workItem.input.editColInput.source.xid = XcalarApiXidInvalidT;
    } else {
	workItem.input.editColInput.source.isTable = true;
	workItem.input.editColInput.source.name = tableName;
	workItem.input.editColInput.source.xid = XcalarApiXidInvalidT;
    }
    workItem.input.editColInput.currFieldName = currFieldName;
    workItem.input.editColInput.newFieldName = newFieldName;
    workItem.input.editColInput.newFieldType = newFieldType;

    try {
        var result = thriftHandle.client.queueWork(workItem);

        var statusOutput = result.output.statusOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            statusOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarEditColumn() caught exception: " + ouch);

        var statusOutput = new Status.StatusT();
        statusOutput = StatusT.StatusThriftProtocolError;
    }

    return statusOutput;
}

function xcalarGetStatsByGroupId(thriftHandle, nodeId, groupIdList) {
    console.log("xcalarGetStatsByGroupId(nodeId = " + nodeId.toString() +
                ", numGroupIds = ", + groupIdList.length.toString() + ", ...)");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.statByGroupIdInput = new XcalarApiStatByGroupIdInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGetStatByGroupId;
    workItem.input.statByGroupIdInput.nodeId = nodeId;
    workItem.input.statByGroupIdInput.numGroupId = groupIdList.length;
    workItem.input.statByGroupIdInput.groupId = groupIdList;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var statOutput = result.output.statOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            statOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarGetStatsByGroupId() caught exception: " + ouch);

        var statOutput = new XcalarApiGetStatOutputT();
        statOutput.status = StatusT.StatusThriftProtocolError;
        statOutput.numStats = 0;
    }

    return statOutput;
}

function xcalarResetStats(thriftHandle, nodeId) {
    console.log("xcalarResetStats(nodeId = " + nodeId.toString() + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.statInput = new XcalarApiStatInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiResetStat;
    workItem.input.statInput.nodeId = nodeId;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = result.output.statusOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarResetStats() caught exception: " + ouch);

        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarGetStatGroupIdMap(thriftHandle, nodeId, numGroupId) {
    console.log("xcalarGetStatGroupIdMap(nodeId = " + nodeId.toString() +
                ", numGroupId = " + numGroupId.toString() + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.statInput = new XcalarApiStatInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGetStatGroupIdMap;
    workItem.input.statInput.nodeId = nodeId;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var statGroupIdMapOutput = result.output.statGroupIdMapOutput;
	if (result.jobStatus != StatusT.StatusOk) {
	    statGroupIdMapOutput.status = result.jobStatus;
	}
    } catch(ouch) {
        console.log("xcalarGetStatGroupIdMap() caught exception: " + ouch);

	// XXX FIXME need status field in XcalarApiGetStatGroupIdMapOutputT
        var statGroupIdMapOutput = new XcalarApiGetStatGroupIdMapOutputT();
        statGroupIdMapOutput.status = StatusT.StatusThriftProtocolError;
        statGroupIdMapOutput.numGroupNames = 0;
    }

    return statGroupIdMapOutput;
}

function xcalarQuery(thriftHandle, query) {
    console.log("xcalarQuery(query = " + query + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiQuery;
    workItem.input.queryInput = query;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var queryOutput = result.output.queryOutput;
    } catch (ouch) {
        console.log("xcalarQuery() caught exception: " + ouch);
        var queryOutput = new XcalarApiQueryOutputT();
        queryOutput.status = StatusT.StatusThriftProtocolError;
    }

    return queryOutput;
}

function xcalarQueryState(thriftHandle, queryId) {
    console.log("xcalarQueryState(queryId = " + queryId + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.queryStateInput = new XcalarApiQueryStateInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiQueryState;
    workItem.input.queryStateInput.queryId = queryId;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var queryStateOutput = result.output.queryStateOutput;
    } catch (ouch) {
        console.log("xcalarQueryState() caught exception: " + ouch);
        var queryStateOutput = new XcalarApiQueryStateOutputT();
        queryStateOutput.status = StatusT.StatusThriftProtocolError;
    }

    return queryStateOutput;
}

function xcalarDag(thriftHandle, tableName) {
    console.log("xcalarDag(tableName = " + tableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGetDag;
    workItem.input.dagTableNameInput = tableName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var dagOutput = result.output.dagOutput;
    } catch (ouch) {
        console.log("xcalarDag() caught exception: " + ouch);
        var dagOutput = new XcalarApiDagOutputT();
        dagOutput.status = StatusT.StatusThriftProtocolError;
    }

    return dagOutput;
}

function xcalarListTables(thriftHandle, patternMatch) {
    console.log("xcalarListTables(patternMatch = " + patternMatch + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.apiVersion = 0;
    workItem.api = XcalarApisT.XcalarApiListTables;
    workItem.input.listTablesInput = patternMatch;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var listTablesOutput = result.output.listTablesOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            listTablesOutput.numTables = 0;
        }
    } catch (ouch) {
        console.log("xcalarListTables() caught exception: " + ouch);

        var listTablesOutput = new XcalarApiListTablesOutputT();
        // XXX FIXME should add StatusT.StatusThriftProtocolError
        listTablesOutput.numTables = 0;
    }

    return listTablesOutput;
}

function xcalarListDatasets(thriftHandle) {
    console.log("xcalarListDatasets()");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.apiVersion = 0;
    workItem.api = XcalarApisT.XcalarApiListDatasets;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var listDatasetsOutput = result.output.listDatasetsOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            listDatasetsOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarListDatasets() caught exception: " + ouch);

        var listDatasetsOutput = new XcalarApiListDatasetsOutputT();
        // XXX FIXME should add StatusT.StatusThriftProtocolError
        listDatasetsOutput.numDatasets = 0;
    }

    return listDatasetsOutput;
}

function xcalarMakeResultSetFromTable(thriftHandle, tableName) {
    console.log("xcalarMakeResultSetFromTable(tableName = " + tableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.makeResultSetInput = new XcalarApiNamedInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiMakeResultSet;
    workItem.input.makeResultSetInput.isTable = true;
    workItem.input.makeResultSetInput.name = tableName;
    workItem.input.makeResultSetInput.xid = XcalarApiXidInvalidT;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var makeResultSetOutput = result.output.makeResultSetOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            makeResultSetOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarMakeResultSetFromTable() caught exception: " + ouch);

        var makeResultSetOutput = new XcalarApiMakeResultSetOutputT();
        makeResultSetOutput.status = StatusT.StatusThriftProtocolError;
    }

    return makeResultSetOutput;
}

function xcalarMakeResultSetFromDataset(thriftHandle, datasetName) {
    console.log("xcalarMakeResultSetFromDataset(datasetName = " +
                datasetName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.makeResultSetInput = new XcalarApiNamedInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiMakeResultSet;
    workItem.input.makeResultSetInput.isTable = false;
    workItem.input.makeResultSetInput.name = datasetName;
    workItem.input.makeResultSetInput.xid = XcalarApiXidInvalidT;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var makeResultSetOutput = result.output.makeResultSetOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            makeResultSetOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarMakeResultSetFromDataset() caught exception: " +
                    ouch);

        var makeResultSetOutput = new XcalarApiMakeResultSetOutputT();
        makeResultSetOutput.status = StatusT.StatusThriftProtocolError;
    }

    return makeResultSetOutput;
}

function xcalarResultSetNext(thriftHandle, resultSetId, numRecords) {
    console.log("xcalarResultSetNext(resultSetId = " + resultSetId.toString() +
                ", numRecords = " + numRecords.toString() + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.resultSetNextInput = new XcalarApiResultSetNextInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiResultSetNext;
    workItem.input.resultSetNextInput.resultSetId = resultSetId;
    workItem.input.resultSetNextInput.numRecords = numRecords;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var resultSetNextOutput = result.output.resultSetNextOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            resultSetNextOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarResultSetNext() caught exception: " +
                    ouch);

        var resultSetNextOutput = new XcalarApiResultSetNextOutputT();
        resultSetNextOutput.status = StatusT.StatusThriftProtocolError;
    }

    return resultSetNextOutput;
}

function xcalarJoin(thriftHandle, leftTableName, rightTableName, joinTableName,
                    joinType) {
    console.log("xcalarJoin(leftTableName = " + leftTableName +
                ", rightTableName = " + rightTableName + ", joinTableName = " +
                joinTableName + ", joinType = " + JoinOperatorTStr[joinType] +
                ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.joinInput = new XcalarApiJoinInputT();
    workItem.input.joinInput.leftTable = new XcalarApiTableT();
    workItem.input.joinInput.rightTable = new XcalarApiTableT();
    workItem.input.joinInput.joinTable = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiJoin;
    workItem.input.joinInput.leftTable.tableName = leftTableName;
    workItem.input.joinInput.leftTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.joinInput.rightTable.tableName = rightTableName;
    workItem.input.joinInput.rightTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.joinInput.joinTable.tableName = joinTableName;
    workItem.input.joinInput.joinTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.joinInput.joinType = joinType;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var joinOutput = result.output.joinOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            joinOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarJoin() caught exception: " + ouch);

        var joinOutput = new XcalarApiNewTableOutputT();
        joinOutput.status = StatusT.StatusThriftProtocolError;
    }

    return joinOutput;
}

function xcalarFilter(thriftHandle, filterStr, srcTableName, dstTableName) {
    console.log("xcalarFilter(srcTableName = " + srcTableName +
                ", dstTableName = " + dstTableName + ", filterStr = " +
                filterStr + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.filterInput = new XcalarApiFilterInputT();
    workItem.input.filterInput.srcTable = new XcalarApiTableT();
    workItem.input.filterInput.dstTable = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiFilter;
    workItem.input.filterInput.srcTable.tableName = srcTableName;
    workItem.input.filterInput.srcTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.filterInput.dstTable.tableName = dstTableName;
    workItem.input.filterInput.dstTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.filterInput.filterStr = filterStr;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var filterOutput = result.output.filterOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            filterOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarFilter() caught exception: " + ouch);
        var filterOutput = new XcalarApiNewTableOutputT();
        filterOutput.status = StatusT.StatusThriftProtocolError;
    }

    return filterOutput;
}

function xcalarGroupBy(thriftHandle, srcTableName, dstTableName, groupByOp,
                       fieldName, newFieldName) {
    console.log("xcalarGroupBy(srcTableName = " + srcTableName +
                ", dstTableName = " + dstTableName + ", groupByOp = " +
                AggregateOperatorTStr[groupByOp] + ", fieldName = " + fieldName +
                ", newFieldName = " + newFieldName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.groupByInput = new XcalarApiGroupByInputT();
    workItem.input.groupByInput.table = new XcalarApiTableT();
    workItem.input.groupByInput.groupByTable = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGroupBy;
    workItem.input.groupByInput.table.tableName = srcTableName;
    workItem.input.groupByInput.table.tableId = XcalarApiTableIdInvalidT;
    workItem.input.groupByInput.groupByTable.tableName = dstTableName;
    workItem.input.groupByInput.groupByTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.groupByInput.groupByOp = groupByOp;
    workItem.input.groupByInput.fieldName = fieldName;
    workItem.input.groupByInput.newFieldName = newFieldName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var groupByOutput = result.output.groupByOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            groupByOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarGroupBy() caught exception: " + ouch);

        var groupByOutput = new XcalarApiNewTableOutputT();
        groupByOutput.status = StatusT.StatusThriftProtocolError;
    }

    return groupByOutput;
}

function xcalarResultSetAbsolute(thriftHandle, resultSetId, position) {
    console.log("xcalarResultSetAbsolute(resultSetId = " +
                resultSetId.toString() + ", position = " +
                position.toString() + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.resultSetAbsoluteInput =
        new XcalarApiResultSetAbsoluteInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiResultSetAbsolute;
    workItem.input.resultSetAbsoluteInput.resultSetId = resultSetId;
    workItem.input.resultSetAbsoluteInput.position = position;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = result.output.statusOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarResultSetAbsolute() caught exception: " +
                    ouch);

        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarFreeResultSet(thriftHandle, resultSetId) {
    console.log("xcalarResultSetAbsolute(resultSetId = " +
                resultSetId.toString() + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.freeResultSetInput =        new XcalarApiFreeResultSetInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiFreeResultSet;
    workItem.input.freeResultSetInput.resultSetId = resultSetId;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        // XXX FIXME bug 136
        var status = StatusT.StatusOk;
        if (result.jobStatus != StatusT.StatusOk) {
            status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarResultSetAbsolute() caught exception: " +
                    ouch);

        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarDeleteTable(thriftHandle, tableName) {
    console.log("xcalarDeleteTable(tableName = " + tableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.deleteTableInput =  new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiDeleteTable;
    workItem.input.deleteTableInput.tableName = tableName;
    workItem.input.deleteTableInput.tableId = XcalarApiTableIdInvalidT;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = result.output.statusOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarDeleteTable() caught exception: " + ouch);

        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarGetTableRefCount(thriftHandle, tableName) {
    console.log("xcalarGetTableRefCount(tableName = " + tableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.getTableRefCountInput = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGetTableRefCount;
    workItem.input.getTableRefCountInput.tableName = tableName;
    workItem.input.getTableRefCountInput.tableId = XcalarApiTableIdInvalidT;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var getTableRefCountOutput = result.output.getTableRefCountOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            getTableRefCountOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarDeleteTable() caught exception: " + ouch);

        var getTableRefCountOutput = new XcalarApiGetTableRefCountOutputT();
        getTableRefCountOutput.status = StatusT.StatusThriftProtocolError;
    }

    return getTableRefCountOutput;
}

function xcalarBulkDeleteTables(thriftHandle, tableNamePattern) {
    console.log("xcalarBulkDeleteTables(tableNamePattern = " +
                tableNamePattern + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiBulkDeleteTables;
    workItem.input.bulkDeleteTablesInput = tableNamePattern;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var deleteTablesOutput = result.output.deleteTablesOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            deleteTablesOutput.status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarBulkDeleteTables() caught exception: " + ouch);

        var deleteTablesOutput = new XcalarApiBulkDeleteTablesOutputT();
        deleteTablesOutput.status = StatusT.StatusThriftProtocolError;
    }

    return deleteTablesOutput;
}

function xcalarDestroyDataset(thriftHandle, datasetName) {
    console.log("xcalarDestroyDataset(datasetName = " + datasetName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiDestroyDataset;
    workItem.input.destroyDsInput = datasetName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = result.output.statusOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            status = result.jobStatus;
        }
    } catch(ouch) {
        console.log("xcalarDestroyDataset() caught exception: " + ouch);
        
        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarApiMap(thriftHandle, newFieldName, evalStr, srcTableName,
                      dstTableName) {
    console.log("xcalarApiMap(newFieldName = " + newFieldName + ", evalStr = "
                + evalStr + ", srcTableName = " +
                srcTableName + ", dstTableName = " + dstTableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.mapInput = new XcalarApiMapInputT();
    workItem.input.mapInput.srcTable = new XcalarApiTableT();
    workItem.input.mapInput.dstTable = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiMap;
    workItem.input.mapInput.evalStr = evalStr;
    workItem.input.mapInput.srcTable.tableName = srcTableName;
    workItem.input.mapInput.srcTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.mapInput.dstTable.tableName = dstTableName;
    workItem.input.mapInput.dstTable.tableId = XcalarApiTableIdInvalidT;
    workItem.input.mapInput.newFieldName = newFieldName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var mapOutput = result.output.mapOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            mapOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarApiMap() caught exception: " + ouch);

        var mapOutput = new XcalarApiNewTableOutputT();
        mapOutput.status = StatusT.StatusThriftProtocolError;
    }

    return mapOutput;
}

function xcalarAggregate(thriftHandle, srcTableName, aggregateOp, fieldName) {
    console.log("xcalarAggregate(srcTableName = " + srcTableName +
                ", aggregateOp = " + AggregateOperatorTStr[aggregateOp] +
                ", fieldName = " + fieldName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.aggregateInput = new XcalarApiAggregateInputT();
    workItem.input.aggregateInput.table = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiAggregate;
    workItem.input.aggregateInput.table.tableName = srcTableName;
    workItem.input.aggregateInput.table.tableId = XcalarApiTableIdInvalidT;
    workItem.input.aggregateInput.aggregateOp = aggregateOp;
    workItem.input.aggregateInput.fieldName = fieldName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var aggregateOutput = result.output.aggregateOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            aggregateOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarAggregate() caught exception: " + ouch);

        var aggregateOutput = new XcalarApiAggregateOutputT();
        aggregateOutput.status = StatusT.StatusThriftProtocolError;
    }

    return aggregateOutput;
}

function xcalarExport(thriftHandle, tableName, fileName) {
    console.log("xcalarExport(tableName = " + tableName + ", fileName = " +
                fileName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.exportInput = new XcalarApiExportInputT();
    workItem.input.exportInput.srcTable = new XcalarApiTableT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiExport;
    workItem.input.exportInput.srcTable.tableName = tableName;
    workItem.input.exportInput.fileName = fileName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var exportOutput = result.output.exportOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            exportOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarExport() caught exception: " + ouch);

        var exportOutput = new XcalarApiExportOutputT();
        exportOutput.status = StatusT.StatusThriftProtocolError;
    }

    return exportOutput;
}

function xcalarListFiles(thriftHandle, url) {
    console.log("xcalarListFiles(url = " + url + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.listFilesInput = new XcalarApiListFilesInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiListFiles;
    workItem.input.listFilesInput.url = url;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var listFilesOutput = result.output.listFilesOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            listFilesOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarListFiles() caught exception: " + ouch);

        var listFilesOutput = new XcalarApiListFilesOutputT();
	listFilesOutput.status = StatusT.StatusThriftProtocolError;
        listFilesOutput.numFiles = 0;
    }

    return listFilesOutput;
}

function xcalarMakeRetina(thriftHandle, retinaName, tableName) {
    console.log("xcalarMakeRetina(retinaName = " + retinaName +
                ", tableName = " + tableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.makeRetinaInput = new XcalarApiMakeRetinaInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiMakeRetina;
    workItem.input.makeRetinaInput.retinaName = retinaName;
    workItem.input.makeRetinaInput.tableName = tableName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = (result.jobStatus != StatusT.StatusOk) ?
                     result.jobStatus : result.output.statusOutput;
    } catch (ouch) {
        console.log("xcalarMakeRetina() caught exception: " + ouch);
        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarListRetinas(thriftHandle) {
    console.log("xcalarListRetinas()");

    var workItem = new XcalarApiWorkItemT();
    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiListRetinas;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var listRetinasOutput = result.output.listRetinasOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            listRetinasOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarListRetinas() caught exception: " + ouch);

        var listRetinasOutput = new XcalarApiListRetinasOutputT();
        listRetinasOutput.status = StatusT.StatusThriftProtocolError;
        listRetinasOutput.numRetinas = 0;
    }

    return listRetinasOutput;
}

function xcalarGetRetina(thriftHandle, retinaName) {
    console.log("xcalarGetRetina(retinaName = " + retinaName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiGetRetina;
    workItem.input.getRetinaInput = retinaName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var getRetinaOutput = result.output.getRetinaOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            getRetinaOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarGetRetina() caught exception: " + ouch);

        var getRetinaOutput = new XcalarApiGetRetinaOutputT();
        getRetinaOutput.status = StatusT.StatusThriftProtocolError;
    }

    return getRetinaOutput;
}

function xcalarUpdateRetina(thriftHandle, retinaName, dagNodeId,
                            paramType, paramInput) {
    console.log("xcalarUpdateRetina(retinaName = " + retinaName + ", " +
                "dagNodeId = " + dagNodeId + ", paramType = " + paramType +
                ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.updateRetinaInput = new XcalarApiUpdateRetinaInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiUpdateRetina;
    workItem.input.updateRetinaInput.retinaName = retinaName;
    workItem.input.updateRetinaInput.dagNodeId = dagNodeId;
    workItem.input.updateRetinaInput.paramType = paramType;
    workItem.input.updateRetinaInput.paramInput = paramInput;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = (result.jobStatus != StatusT.StatusOk) ?
                     result.jobStatus : result.output.statusOutput;
    } catch (ouch) {
        console.log("xcalarUpdateRetina() caught exception: " + ouch);
        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarExecuteRetina(thriftHandle, retinaName, dstTableName,
                             exportFileName, parameters) {
    console.log("xcalarExecuteRetina(retinaName = " + retinaName + ", " +
                "dstTableName = " + dstTableName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.executeRetinaInput = new XcalarApiExecuteRetinaInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiExecuteRetina;
    workItem.input.executeRetinaInput.retinaName = retinaName;
    workItem.input.executeRetinaInput.dstTableName = dstTableName;
    workItem.input.executeRetinaInput.exportToFile = (exportFileName != null);
    workItem.input.executeRetinaInput.exportFileName = exportFileName;
    workItem.input.executeRetinaInput.numParameters = parameters.length;
    workItem.input.executeRetinaInput.parameters = parameters;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = (result.jobStatus != StatusT.StatusOk) ?
                     result.jobStatus : result.output.statusOutput;
    } catch (ouch) {
        console.log("xcalarExecuteRetina() caught exception: " + ouch);
        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarAddParameterToRetina(thriftHandle, retinaName, parameterName,
                                    parameterValue) {
    console.log("xcalarAddParameterToRetina(retinaName = " + retinaName +
                ", parameterName = " + parameterName + ", parameterValue = " +
                parameterValue + ")");
    
    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();
    workItem.input.addParameterToRetinaInput = new XcalarApiAddParameterToRetinaInputT();
    workItem.input.addParameterToRetinaInput.parameter = new XcalarApiParameterT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiAddParameterToRetina;
    workItem.input.addParameterToRetinaInput.retinaName = retinaName;
    workItem.input.addParameterToRetinaInput.parameter.parameterName = parameterName;
    workItem.input.addParameterToRetinaInput.parameter.parameterValue = parameterValue;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var status = (result.jobStatus != StatusT.StatusOk) ?
                     result.jobStatus : result.output.statusOutput;
    } catch (ouch) {
        console.log("xcalarAddParameterToRetina() caught exception: " + ouch);
        var status = StatusT.StatusThriftProtocolError;
    }

    return status;
}

function xcalarListParametersInRetina(thriftHandle, retinaName) {
    console.log("xcalarListParametersInRetina(retinaName = " + retinaName + ")");

    var workItem = new XcalarApiWorkItemT();
    workItem.input = new XcalarApiInputT();

    workItem.apiVersionSignature = XcalarApiVersionT.XcalarApiVersionSignature;
    workItem.api = XcalarApisT.XcalarApiListParametersInRetina;
    workItem.input.listParametersInRetinaInput = retinaName;

    try {
        var result = thriftHandle.client.queueWork(workItem);
        var listParametersInRetinaOutput = result.output.listParametersInRetinaOutput;
        if (result.jobStatus != StatusT.StatusOk) {
            listParametersInRetinaOutput.status = result.jobStatus;
        }
    } catch (ouch) {
        console.log("xcalarListParametersInRetina() caught exception: " + ouch);
        var listParametersInRetinaOutput = new XcalarApiListParametersInRetinaOutputT();
        listParametersInRetinaOutput.status = StatusT.StatusThriftProtocolError;
        listParametersInRetinaOutput.numParameters = 0;
    }

    return listParametersInRetinaOutput;
}
// Witness to bug 568

// XXX i can't find a javascript sleep()
function busywait(millis)
{
    var date = new Date();
    var curDate = null;
    do { curDate = new Date(); }
    while(curDate-date < millis);
}

function pass(testName, currentTestNumber)
{
    console.log("ok " + currentTestNumber + " - Test \"" + testName +
                "\" passed");
}

function fail(testName, currentTestNumber)
{
    console.log("not ok " + currentTestNumber + " - Test \"" + testName +
                "\" failed");
}

function skip(testName, currentTestNumber)
{
    console.log("ok " + currentTestNumber + " - Test \"" + testName +
                "\" disabled # SKIP");
}

thriftHandle = xcalarConnectThrift("localhost", 9090);

currentTestNumber=0;
returnValue=0;

currentTestNumber++;
testName="startNodes";
console.log("==========================================");
console.log("Testing \"" + testName + "\":")
status = xcalarStartNodes(thriftHandle, 2);
console.log("\tstatus: " + StatusTStr[status]);
console.log("RESULT:")
if (status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="load";
console.log("==========================================");
console.log("Testing \"" + testName + "\":");
loadArgs = new XcalarApiDfLoadArgsT();
loadArgs.csv = new XcalarApiDfCsvLoadArgsT();
loadArgs.csv.recordDelim = "";
loadArgs.csv.fieldDelim = "";
loadOutput = xcalarLoad(thriftHandle, "file:///var/tmp/qa/indexJoin/classes", "classes", DfFormatTypeT.DfTypeJson, 0, loadArgs);
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[loadOutput.status]);
if (loadOutput.status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
    console.log("FAIL: load");
} else {
    console.log("\tdataset: " + loadOutput.dataset.name);
    pass(testName, currentTestNumber);
}

origDataset = loadOutput.dataset.name;

currentTestNumber++;
testName="index dataset (class_id)";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
syncIndexOutput = xcalarIndexDataset(thriftHandle,
                  origDataset, "class_id",
                  "classes/class_id");
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[syncIndexOutput.status]);
if (syncIndexOutput.status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    console.log("\ttableName: " + syncIndexOutput.tableName);
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="join1";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
newTableOutput = xcalarJoin(thriftHandle, "classes/class_id",
			    "classes/class_id",
			    "classes/class_id/nest1",
			    JoinOperatorT.InnerJoin);
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[newTableOutput.status]);
if (newTableOutput.status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    console.log("\ttableName: " + newTableOutput.tableName);
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="join2";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
newTableOutput = xcalarJoin(thriftHandle, "classes/class_id/nest1",
			    "classes/class_id/nest1",
			    "classes/class_id/nest2",
			    JoinOperatorT.InnerJoin);
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[newTableOutput.status]);
if (newTableOutput.status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    console.log("\ttableName: " + newTableOutput.tableName);
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="join3";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
newTableOutput = xcalarJoin(thriftHandle, "classes/class_id/nest2",
			    "classes/class_id/nest2",
			    "classes/class_id/nest3",
			    JoinOperatorT.InnerJoin);
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[newTableOutput.status]);
if (newTableOutput.status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    console.log("\ttableName: " + newTableOutput.tableName);
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="join4";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
newTableOutput = xcalarJoin(thriftHandle, "classes/class_id/nest3",
			    "classes/class_id/nest3",
			    "classes/class_id/nest4",
			    JoinOperatorT.InnerJoin);
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[newTableOutput.status]);
if (newTableOutput.status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    console.log("\ttableName: " + newTableOutput.tableName);
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="dag";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");

for (i = 0; i < 100; i++) {
    dagOutput = xcalarDag(thriftHandle, newTableOutput.tableName);
    console.log("RESULT:");
    console.log("\tstatus: " + StatusTStr[dagOutput.status]);
    if (dagOutput.status != StatusT.StatusOk) {
	returnValue=1;
    }
}
if (returnValue != 1) {
    pass(testName, currentTestNumber);
} else {
    fail(testName, currentTestNumber);
}

currentTestNumber++;
testName="bulk delete tables";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
deleteTablesOutput = xcalarBulkDeleteTables(thriftHandle, "*");
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[deleteTablesOutput.status]);
if (deleteTablesOutput.status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    for (i = 0; i < deleteTablesOutput.numTables; i++) {
        delTableStatus = deleteTablesOutput.statuses[i];
        console.log("\t" + delTableStatus.table.tableName + ": " +
                    StatusTStr[delTableStatus.status]);
    }
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="destroy dataset";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
status = xcalarDestroyDataset(thriftHandle, origDataset);
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[status]);
if (status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    pass(testName, currentTestNumber);
}

currentTestNumber++;
testName="shutdown";
console.log("==========================================");
console.log("Testing \"" + testName + "\":\n");
status = xcalarShutdown(thriftHandle);
console.log("RESULT:");
console.log("\tstatus: " + StatusTStr[status]);
if (status != StatusT.StatusOk) {
    returnValue=1;
    fail(testName, currentTestNumber);
} else {
    pass(testName, currentTestNumber);
}

console.log("==========================================");

console.log("1.." + currentTestNumber + "\n")
phantom.exit(returnValue);
