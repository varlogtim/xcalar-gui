import { expect } from 'chai'
import { FileType, defaultInputSerialization, FileTypeNamePattern } from './SchemaService'
import { createDiscoverApp, isFailedSchema } from './SchemaLoadService'
import { LoadSession, RandomSession } from './sdk/Session'
import { Table } from './sdk/Table'
import { randomName } from './sdk/Api'

describe('SchemaLoadService Test', function() {
    let app = null;
    let selectedSchemaHash = null;
    let tableQuery = null;
    let resultTables = null;
    const publishedTables = {
        data: null, icv: null
    };
    let imdNode = null;
    const dataSchema = [
        { "name": "R", "type": "string" },
        { "name": "C", "type": "string" },
        { "name": "E", "type": "string" },
        { "name": "I", "type": "string" },
        { "name": "J", "type": "string" },
        { "name": "_X_PATH", "type": "string" }
    ];

    before(async () => {
        await cleanupSession();

        app = createDiscoverApp({
            path: '/xcfield/instantdatamart/mdmdemo/000fccb',
            filePattern: FileTypeNamePattern.get(FileType.CSV),
            inputSerialization: defaultInputSerialization.get(FileType.CSV),
            isRecursive: true
        });
        expect(app != null, 'Check Load App').to.be.true;
        await app.init();
        await app.run();
    });

    after(async () => {
        await cleanupSession();
        if (publishedTables.data != null) {
            try {
                await deleteIMD(publishedTables.data);
            } catch(_) {
                // Ignore error
            }
        }
        if (publishedTables.icv != null) {
            try {
                await deleteIMD(publishedTables.icv);
            } catch(_) {
                // Ignore error
            }
        }
    });

    /**
     * Check metadata tables generated by discover_all
     */
    it ('Metadata tables of schema discovery', async () => {
        const reportTable = await app.waitForReportTable();
        expect(reportTable != null, 'Check Report Table').to.be.true;

        const fileTable = await app.waitForFileTable();
        expect(fileTable != null, 'Check File Table').to.be.true;

        const schemaTable = await app.waitForReportTable();
        expect(schemaTable != null, 'Check Schema Table').to.be.true;

        // Randomly choose one schema
        const discoverReport = await app.getReport(0, 10);
        for (const { schema } of discoverReport.schemas) {
            if (!isFailedSchema(schema.hash)) {
                selectedSchemaHash = schema.hash;
                break;
            }
        }
        expect(selectedSchemaHash != null, 'Check Selected Schema').to.be.true;
    });

    /**
     * Check query strings returned by get_dataflow
     */
    it('Dataflow to create table', async () => {
        // Generate DFs
        tableQuery = await app.getCreateTableQuery(selectedSchemaHash);
        expect(tableQuery != null, 'Check Table Queries').to.be.true;
    });

    /**
     * Check dataflow execution for creating final tables
     * Note: the execution must be kind of drop-as-you-go
     * which means the intermediate datasets/tables will be deleted during execution
     */
    it('DF execution', async () => {
        const session = app.getSession();
        const numTablesBefore = (await session.listTables({
            namePattern: '*', isGlobal: false
        })).length;
        const numDatasetsBefore = (await session.callLegacyApi(
            () => XcalarGetDatasets()
        )).datasets.length;

        // Execute DFs and create tables
        resultTables = await app.createResultTables(tableQuery);

        // Validation
        // Verify existence of load/data/comp tables
        expect(resultTables != null).to.be.true;
        let isICVExist = false;
        try {
            await resultTables.comp.getInfo();
            isICVExist = true;
        } catch(_) {
            isICVExist = false;
        }
        expect(isICVExist, 'Check ICV table existence').to.be.true;

        let isDataExist = false;
        try {
            await resultTables.data.getInfo();
            isDataExist = true;
        } catch(_) {
            isDataExist = false;
        }
        expect(isDataExist, 'Check Data table existence').to.be.true;

        let isLoadExist = false;
        try {
            await resultTables.load.getInfo();
            isLoadExist = true;
        } catch(_) {
            isLoadExist = false;
        }
        // Load table: XDB should be deleted, but dag should be there
        expect(isLoadExist, 'Check Load table existence').to.be.false;

        // Verify temp. table cleanup
        const numTablesAfter = (await session.listTables({
            namePattern: '*', isGlobal: false
        })).length;
        expect(numTablesAfter).to.equal(numTablesBefore + 2);

        // Verify datasets
        const numDatasetsAfter = (await session.callLegacyApi(
            () => XcalarGetDatasets()
        )).datasets.length;
        expect(numDatasetsBefore).to.equal(numDatasetsAfter);
    });

    /**
     * Check IMD tables created on top of final tables
     */
    it('Publish tables', async () => {
        const baseName = `TEST_LOAD_${randomName().toUpperCase()}`;
        const dataName = `${baseName}_DATA`;
        const icvName = `${baseName}_ICV`;

        // Publish tables
        const compHasData = await app.publishResultTables(
            resultTables,
            { data: dataName, comp: icvName },
            tableQuery
        );

        // Validation
        // Verify existence of IMD tables
        const dataTable = await app.getSession().getPublishedTable({ name: dataName });
        expect(dataTable != null, 'Check Data table exists').to.be.true;
        const icvTable = await app.getSession().getPublishedTable({ name: icvName });
        if (compHasData) {
            expect(icvTable != null, 'Check ICV table exists').to.be.true;
        } else {
            expect(icvTable == null, 'Check ICV table not exists').to.be.true;
        }

        publishedTables.data = dataName;
        publishedTables.icv = icvName;
    });

    /**
     * Check IMD's native restoration
     */
    it('Restore IMD table', async () => {
        const tableName = publishedTables.data;
        await deactivateIMD(tableName);
        await activateIMD(tableName);

        // Validation
        const imdTable = await app.getSession().getPublishedTable({
            name: tableName
        });
        expect(imdTable != null, 'Check Data table exists').to.be.true;
        expect(imdTable.isActive(), 'Check Data table active').to.be.true;
    });

    /**
     * Check XD's restoration
     */
    it('Restore IMD table from source node', async ()=> {
        const tableName = publishedTables.data;
        imdNode = new DagNodeIMDTable({
            schema: dataSchema.map((s) => ({...s}))
        });
        imdNode.setParam({
            source: tableName,
            schema: dataSchema.map((s) => ({...s}))
        });
        await imdNode.fetchAndSetSubgraph(tableName);

        // Delete IMD table
        await deleteIMD(tableName);
        // Restore from source node
        await PTblManager.Instance.restoreTableFromNode(imdNode);

        // Validation
        const imdTable = await app.getSession().getPublishedTable({
            name: tableName
        });
        expect(imdTable != null, 'Check Data table exists').to.be.true;
        expect(imdTable.isActive(), 'Check Data table active').to.be.true;
    });

    /**
     * Check download app -> execute app
     */
    it('Execute Data App', async () => {
        const randName = randomName();
        const moduleName = `test_module_${randName}`;
        const moduleId = `DF2_${randName}`;
        const appId = AppList.generateId();

        // Create dataflow with IMD node
        const dagGraph = new DagGraph();
        try {
            dagGraph.initialize();
            dagGraph.addNode(imdNode);
            const outNode = dagGraph.newNode({
                type: DagNodeType.DFOut
            });
            outNode.setParam({
                name: 'test_exec_out',
                linkAfterExecution: false
            });
            dagGraph.connect(imdNode.getId(), outNode.getId());
        } catch(e) {
            expect(true, 'Create dataflow failed').to.be.false;
        }

        // Create Module
        let moduleTab;
        try {
            moduleTab = createUserTab({
                name: moduleName,
                id: moduleId,
                app: appId,
                dagGraph: dagGraph
            });
            DagList.Instance.addDag(moduleTab);
        } catch(e) {
            expect(true, 'Create module failed').to.be.false;
        }

        // Download App
        const loadUdf = {};
        let sessionContent;
        try {
            const fakeTab = new DagTabPublished({
                name: xcHelper.randName("App"),
                dagGraph: null
            });
            fakeTab._findLoaderUDFs(moduleTab, loadUdf);
            await fakeTab.publishApp(appId);

            DagTabPublished._switchSession(null);
            const downloadResult = XcalarDownloadWorkbook(fakeTab._getWKBKName(), "");
            DagTabPublished._resetSession();
            sessionContent = (await downloadResult).sessionContent;
        } catch(e) {
            expect(true, 'Download app failed').to.be.false;
        }

        // Delete shared load udfs
        // to make sure uploaded app only calls workbook udfs
        try {
            for (const [udfPath, _] of Object.entries(loadUdf)) {
                await XcalarDeletePython(udfPath, true);
            }
        } catch(e) {
            expect(true, 'Delete streaming udf failed').to.be.false;
        }
        // const xdfs = await XcalarListXdfs("*get_load_wizard_plan*", "User*");
        // console.log(xdfs);

        // Upload App
        const execSession = new RandomSession();
        try {
            await execSession.callLegacyApi(
                () => XcalarUploadWorkbook(execSession.sessionName, sessionContent, '')
            );
        } catch(e) {
            expect(true, 'Upload app failed').to.be.false;
        }

        try {
            try {
                await execSession.activate();
                // const xdfs = await execSession.callLegacyApi(() => XcalarListXdfs("*get_load_wizard_plan*", "User*"));
                // console.log(xdfs);
            } catch(e) {
                expect(true, 'Activate execution session failed').to.be.false;
            }

            // Get graph to execute
            const execGraph = new DagGraph();
            try {
                const keyList = await execSession.callLegacyApi(
                    () => XcalarKeyList('DF2_', gKVScope.WKBK)
                );
                const dfKey = keyList.keys[0];
                expect(dfKey != null, 'Module/Dataflow not found').to.be.true;
                const execSerializedGraph = (await execSession.callLegacyApi(
                    () => XcalarKeyLookup(dfKey, gKVScope.WKBK)
                )).value;
                execGraph.create(JSON.parse(execSerializedGraph).dag);
            } catch(e) {
                expect(true, 'Create graph failed').to.be.false;
            }

            // Optimized execute
            let destTable;
            try {
                const retinaInfo = (await execGraph.getRetinaArgs()).retina;
                const tables = JSON.parse(retinaInfo.retina).tables;
                destTable = tables[tables.length - 1].name;

                await execSession.executeQueryOptimized({
                    queryStringOpt: retinaInfo.retina,
                    queryName: `ret_${randName}`,
                    tableName: destTable
                });
            } catch(e) {
                expect(true, 'Execute app failed').to.be.false;
            }

            // Validation
            const dataTable = new Table({ session: execSession, tableName: destTable });
            let isDataExist = false;
            try {
                const tableInfo = await dataTable.getInfo();
                expect(tableInfo.columns.length, 'Validate table metadata').to.equal(dataSchema.length);
                isDataExist = true;
            } catch(_) {
                isDataExist = false;
            }
            expect(isDataExist, 'Check Data table existence').to.be.true;
        } finally {
            // Cleanup
            await execSession.destroy();
        }
    });

    async function cleanupSession() {
        try {
            const loadSession = new LoadSession();
            await loadSession.destroy();
        } catch(_) {
            // Ignore errors
        }
    }

    async function deactivateIMD(name) {
        const tableInfo = new PbTblInfo({ name: name });
        await tableInfo.deactivate();
    }

    async function activateIMD(name) {
        const tableInfo = new PbTblInfo({ name: name });
        await tableInfo.activate();
    }

    async function deleteIMD(name) {
        const tableInfo = new PbTblInfo({ name: name });
        await tableInfo.delete();
    }

    function createUserTab({ name, id, app, dagGraph }) {
        return new DagTabUser({
            name: name, id: id, app: app, dagGraph: dagGraph,
            type: 'Normal', createdTime: Date.now(),
        });
    }
});